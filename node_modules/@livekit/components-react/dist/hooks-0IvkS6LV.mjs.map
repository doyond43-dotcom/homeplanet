{"version":3,"file":"hooks-0IvkS6LV.mjs","sources":["../src/hooks/internal/useResizeObserver.ts","../src/hooks/internal/useObservableState.ts","../src/hooks/internal/useMediaQuery.ts","../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useConnectionQualityIndicator.ts","../src/hooks/useConnectionStatus.ts","../src/hooks/useDataChannel.ts","../src/hooks/useDisconnectButton.ts","../src/hooks/useFacingMode.ts","../src/hooks/useFocusToggle.ts","../src/hooks/useGridLayout.ts","../src/hooks/useIsMuted.ts","../src/hooks/useIsSpeaking.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useLocalParticipantPermissions.ts","../src/hooks/useMediaDeviceSelect.ts","../src/hooks/useMediaDevices.ts","../src/hooks/useVisualStableUpdate.ts","../src/hooks/usePagination.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useParticipantTile.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/usePinnedTracks.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useStartAudio.ts","../src/hooks/useStartVideo.ts","../src/hooks/useSwipe.ts","../src/hooks/useChatToggle.ts","../src/hooks/useToken.ts","../src/hooks/useTrackMutedIndicator.ts","../src/hooks/useTrackToggle.ts","../src/hooks/useTracks.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useChat.ts","../src/hooks/usePersistentUserChoices.ts","../src/hooks/useIsEncrypted.ts","../src/hooks/useTrackVolume.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts","../src/hooks/useSequentialRoomConnectDisconnect.ts","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/hooks/useAgent.ts","../src/hooks/useSession.ts","../src/hooks/useEvents.ts","../src/hooks/useSessionMessages.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\n\nconst useLatest = <T>(current: T) => {\n  const storedValue = React.useRef(current);\n  React.useEffect(() => {\n    storedValue.current = current;\n  });\n  return storedValue;\n};\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(\n  observable: Observable<T> | undefined,\n  startWith: T,\n  resetWhenObservableChanges = true,\n) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    if (resetWhenObservableChanges) {\n      setState(startWith);\n    }\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable, resetWhenObservableChanges]);\n  return state;\n}\n","import * as React from 'react';\n/**\n * Implementation used from https://github.com/juliencrn/usehooks-ts\n *\n * @internal\n */\nexport function useMediaQuery(query: string): boolean {\n  const getMatches = (query: string): boolean => {\n    // Prevents SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  };\n\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\n\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n\n  React.useEffect(() => {\n    const matchMedia = window.matchMedia(query);\n\n    // Triggered at the first client-side load and if query changes\n    handleChange();\n\n    // Listen matchMedia\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener('change', handleChange);\n    }\n\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener('change', handleChange);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n\n  return matches;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, p.connectionQuality);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton(buttonProps);\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\n  }, [trackReference, layoutContext?.pin.state]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (inFocus) {\n            layoutContext?.pin.dispatch?.({\n              msg: 'clear_pin',\n            });\n          } else {\n            layoutContext?.pin.dispatch?.({\n              msg: 'set_pin',\n              trackReference,\n            });\n          }\n        },\n      }),\n    [props, className, trackReference, inFocus, layoutContext?.pin],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n  options: {\n    gridLayouts?: GridLayoutDefinition[];\n  } = {},\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\n  const { width, height } = useSize(gridElement);\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n    containerWidth: width,\n    containerHeight: height,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example With a track reference\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n *\n * @example With a track source / participant\n * ```tsx\n * const isMuted = useIsMuted('camera', { participant });\n * ```\n *\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\n * @param options - Additional options when using a `Track.Source`\n * @returns boolean indicating if the track is muted\n *\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(localParticipant.isCameraEnabled);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isScreenShareEnabled,\n  );\n\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\n\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\n    roomFallback?.getActiveDevice(kind) ?? 'default',\n  );\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, roomFallback),\n    [kind, roomFallback, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      if (!deviceId) {\n        return;\n      }\n      log.info('setCurrentDeviceId', deviceId);\n      setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({\n  kind,\n  onError,\n}: {\n  kind: MediaDeviceKind;\n  onError?: (e: Error) => void;\n}) {\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError),\n    [kind, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\nimport { Track } from 'livekit-client';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrackPublication(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\n  const micRef = React.useMemo(() => {\n    return {\n      participant: trackReference.participant,\n      source: Track.Source.Microphone,\n      publication: micTrack,\n    };\n  }, [micTrack, trackReference.participant]);\n  const isVideoMuted = useIsMuted(trackReference);\n  const isAudioMuted = useIsMuted(micRef);\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { Room } from 'livekit-client';\n\n/** @public */\nexport type UseSpeakingParticipantsOptions = {\n  room?: Room;\n};\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants(options?: UseSpeakingParticipantsOptions) {\n  const ensuredRoom = useEnsureRoom(options?.room);\n\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(ensuredRoom), [ensuredRoom]);\n  const activeSpeakers = useObservableState(speakerObserver, ensuredRoom.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { useObservableState } from './internal';\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(trackReference),\n    [getTrackReferenceId(trackReference)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(\n      trackReference.publication?.isMuted ||\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\n    ),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport { type Room } from 'livekit-client';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {\n  room?: Room;\n}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  publishOptions,\n  onDeviceError,\n  room,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const roomFromContext = useMaybeRoomContext();\n  const roomFallback = React.useMemo(() => room ?? roomFromContext, [room, roomFromContext]);\n  const track = roomFallback?.localParticipant?.getTrackPublication(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () =>\n      roomFallback\n        ? setupMediaToggle<T>(source, roomFallback, captureOptions, publishOptions, onDeviceError)\n        : setupManualToggle(),\n    [roomFallback, source, JSON.stringify(captureOptions), publishOptions],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().catch(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n    ? TrackReferenceOrPlaceholder[]\n    : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [\n    room,\n    JSON.stringify(options.onlySubscribed),\n    JSON.stringify(options.updateOnlyOn),\n    JSON.stringify(sources),\n  ]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTrackPublications()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport { ConnectionState, Room } from 'livekit-client';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal/useObservableState';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n *\n * @remarks\n * Message history is not persisted and will be lost if the component is refreshed.\n * You may want to persist message history in the browser, a cache or a database.\n *\n * @returns An object containing:\n * - `chatMessages` - Array of received chat messages\n * - `send` - Function to send a new message\n * - `isSending` - Boolean indicating if a message is currently being sent\n *\n * @example\n * ```tsx\n * function ChatComponent() {\n *   const { chatMessages, send, isSending } = useChat();\n *\n *   return (\n *     <div>\n *       {chatMessages.map((msg) => (\n *         <div key={msg.timestamp}>\n *           {msg.from?.identity}: {msg.message}\n *         </div>\n *       ))}\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\n *         Send Message\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * @public\n */\nexport function useChat(options?: ChatOptions & { room?: Room }) {\n  const room = useEnsureRoom(options?.room);\n  const connectionState = useConnectionState(room);\n  const isDisconnected = React.useMemo(\n    () => connectionState === ConnectionState.Disconnected,\n    [connectionState],\n  ); // used to reset the messages on room disconnect\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\n    () => setupChat(room, options),\n    [room, options, isDisconnected],\n  );\n  const isSending = useObservableState(setup.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\n\n  return { send: setup.send, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant } from 'livekit-client';\nimport type { Participant, Room } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport interface UseIsEncryptedOptions {\n  room?: Room;\n}\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\n  const p = useEnsureParticipant(participant);\n\n  const room = useEnsureRoom(options.room);\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport function useTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n}\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport function useMultibandTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...multibandDefaults, ...options };\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\n    new Array(opts.bands).fill(0),\n  );\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      setFrequencyBands((val) => val.slice().fill(0));\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(opts.loPass, opts.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\n      const totalBins = normalizedFrequencies.length;\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        // Use proportional distribution to evenly divide bins across bands\n        const startIndex = Math.floor((i * totalBins) / opts.bands);\n        const endIndex = Math.floor(((i + 1) * totalBins) / opts.bands);\n        const chunk = normalizedFrequencies.slice(startIndex, endIndex);\n        const chunkLength = chunk.length;\n        if (chunkLength === 0) {\n          chunks.push(0);\n        } else {\n          const summedVolumes = chunk.reduce((acc, val) => (acc += val), 0);\n          chunks.push(summedVolumes / chunkLength);\n        }\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n}\n\n/**\n * @alpha\n */\nexport interface AudioWaveformOptions {\n  barCount?: number;\n  volMultiplier?: number;\n  updateInterval?: number;\n}\n\nconst waveformDefaults = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20,\n} as const satisfies AudioWaveformOptions;\n\n/**\n * @alpha\n */\nexport function useAudioWaveform(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: AudioWaveformOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...waveformDefaults, ...options };\n\n  const aggregateWave = React.useRef(new Float32Array());\n  const timeRef = React.useRef(performance.now());\n  const updates = React.useRef(0);\n  const [bars, setBars] = React.useState<number[]>([]);\n\n  const onUpdate = React.useCallback((wave: Float32Array) => {\n    setBars(\n      Array.from(\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ),\n    );\n  }, []);\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, {\n      fftSize: getFFTSizeValue(opts.barCount),\n    });\n\n    const bufferLength = getFFTSizeValue(opts.barCount);\n    const dataArray = new Float32Array(bufferLength);\n\n    const update = () => {\n      updateWaveform = requestAnimationFrame(update);\n      analyser.getFloatTimeDomainData(dataArray);\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\n      updates.current += 1;\n\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\n        const newData = dataArray.map((v) => v / updates.current);\n        onUpdate(newData);\n        timeRef.current = performance.now();\n        updates.current = 0;\n      }\n    };\n\n    let updateWaveform = requestAnimationFrame(update);\n\n    return () => {\n      cleanup();\n      cancelAnimationFrame(updateWaveform);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\n\n  return {\n    bars,\n  };\n}\n\nfunction getFFTSizeValue(x: number) {\n  if (x < 32) return 32;\n  else return pow2ceil(x);\n}\n\n// function sigmoid(x: number, k = 2, s = 0) {\n//   return 1 / (1 + Math.exp(-(x - s) / k));\n// }\n\nfunction pow2ceil(v: number) {\n  let p = 2;\n  while ((v >>= 1)) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction filterData(audioData: Float32Array, numSamples: number) {\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\n  const filteredData = new Float32Array(numSamples);\n  for (let i = 0; i < numSamples; i++) {\n    const blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\n  }\n  return filteredData;\n}\n\n// function normalizeData(audioData: Float32Array) {\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\n//   return audioData.map((n) => n * multiplier);\n// }\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Room, Track } from 'livekit-client';\nimport { useMaybeParticipantContext } from '../context';\nimport { useParticipants } from './useParticipants';\n\ntype UseParticipantTracksOptions = {\n  participantIdentity?: string;\n  room?: Room;\n};\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks<TrackSource extends Track.Source>(\n  sources: Array<TrackSource>,\n  optionsOrParticipantIdentity:\n    | UseParticipantTracksOptions\n    | UseParticipantTracksOptions['participantIdentity'] = {},\n): Array<TrackReference> {\n  let participantIdentity: UseParticipantTracksOptions['participantIdentity'];\n  let room: UseParticipantTracksOptions['room'];\n  if (typeof optionsOrParticipantIdentity === 'string') {\n    participantIdentity = optionsOrParticipantIdentity;\n  } else {\n    participantIdentity = optionsOrParticipantIdentity?.participantIdentity;\n    room = optionsOrParticipantIdentity?.room;\n  }\n\n  const participantContext = useMaybeParticipantContext();\n  const participants = useParticipants({ room, updateOnlyOn: [] });\n\n  const p = React.useMemo(() => {\n    if (participantIdentity) {\n      return participants.find((p) => p.identity === participantIdentity);\n    }\n    return participantContext;\n  }, [participantIdentity, participants, participantContext]);\n\n  const observable = React.useMemo(() => {\n    if (!p) {\n      return undefined;\n    }\n    return participantTracksObservable(p, { sources });\n  }, [p, JSON.stringify(sources)]);\n\n  const trackRefs = useObservableState(observable, [] as Array<TrackReference>);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n * @deprecated this is an internal hook that's only used by deprecated APIs\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport {\n  ParticipantAgentAttributes,\n  type ReceivedTranscriptionSegment,\n  type TrackReference,\n} from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\nimport { AgentState } from './useAgent';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = ParticipantAgentAttributes.AgentState;\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState, Room } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/** @beta */\nexport type UseTextStreamOptions = {\n  room?: Room;\n};\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string, options?: UseTextStreamOptions) {\n  const room = useEnsureRoom(options?.room);\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic, ParticipantAgentAttributes } from '@livekit/components-core';\nimport { Room } from 'livekit-client';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  room?: Room;\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION, { room: opts?.room });\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(\n                stream.streamInfo.attributes?.[ParticipantAgentAttributes.TranscribedTrackId] ?? '',\n              )\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n","import { Mutex, type Room } from 'livekit-client';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { log } from '@livekit/components-core';\n\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\n\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\n\n/** @public */\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\n};\n\n/**\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\n * running. This hook sequentializes these two operations, so they always happen in order and\n * never overlap.\n *\n * @example\n * ```ts\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\n *\n * // Connecting to a room:\n * useEffect(() => {\n *   connect();\n *   return () => disconnect();\n * }, [connect, disconnect]);\n * ```\n *\n * @public\n */\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\n  room: R,\n): UseSequentialRoomConnectDisconnectResults<R> {\n  const connectDisconnectQueueRef = useRef<\n    Array<\n      | {\n          type: 'connect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.connect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\n          reject: (err: Error) => void;\n        }\n      | {\n          type: 'disconnect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.disconnect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\n          reject: (err: Error) => void;\n        }\n    >\n  >([]);\n\n  // Process room connection / disconnection events and execute them in series\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\n  // events\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\n  const processConnectsAndDisconnects = useCallback(async () => {\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\n      while (true) {\n        const message = connectDisconnectQueueRef.current.pop();\n        if (!message) {\n          unlock();\n          break;\n        }\n\n        switch (message.type) {\n          case 'connect':\n            await message.room\n              .connect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n          case 'disconnect':\n            await message.room\n              .disconnect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n        }\n      }\n    });\n  }, []);\n\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\n  const checkRoomThreshold = useCallback((now: Date) => {\n    let roomChangesInThreshold = 0;\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        roomChangesInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\n      );\n    }\n  }, []);\n\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\n  useEffect(() => {\n    connectDisconnectQueueRef.current = [];\n\n    const now = new Date();\n    roomChangedTimesRef.current.push(now);\n    checkRoomThreshold(now);\n  }, [room, checkRoomThreshold]);\n\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\n    let connectDisconnectsInThreshold = 0;\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\n      const isWithinThreshold =\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        connectDisconnectsInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\n      );\n    }\n  }, []);\n\n  const connect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called connect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  const disconnect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called discconnect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  return {\n    connect: room ? connect : null,\n    disconnect: room ? disconnect : null,\n  } as UseSequentialRoomConnectDisconnectResults<R>;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import {\n  ConnectionState,\n  LocalTrackPublication,\n  ParticipantEvent,\n  ParticipantKind,\n  RemoteParticipant,\n  RoomEvent,\n  Track,\n  Participant,\n} from 'livekit-client';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { EventEmitter } from 'events';\nimport * as React from 'react';\nimport { ParticipantAgentAttributes, TrackReference } from '@livekit/components-core';\n\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { UseSessionReturn } from './useSession';\nimport { useMaybeSessionContext } from '../context';\nimport { useParticipantInfo } from './useParticipantInfo';\n\n// FIXME: make this 10 seconds once room dispatch booting info is discoverable\nconst DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS = 20_000;\n\n/** @see https://github.com/livekit/agents/blob/65170238db197f62f479eb7aaef1c0e18bfad6e7/livekit-agents/livekit/agents/voice/events.py#L97 */\ntype AgentSdkStates = 'initializing' | 'idle' | 'listening' | 'thinking' | 'speaking';\n\n/**\n * State representing the current status of the agent, whether it is ready for speach, etc\n *\n * For most agents (which have the preconnect audio buffer feature enabled), this is the lifecycle:\n *   connecting  pre-connect-buffering  initializing/listening/thinking/speaking\n *\n * For agents without the preconnect audio feature enabled:\n *   connecting  initializing  idle/listening/thinking/speaking\n *\n * If an agent fails to connect:\n *   connecting  pre-connect-buffering/initializing  failed\n *\n * Legacy useVoiceAssistant hook:\n *   disconnected  connecting  initializing  listening/thinking/speaking\n *\n * @beta\n * */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'pre-connect-buffering'\n  | 'failed'\n  | AgentSdkStates;\n\n/** @beta */\nexport enum AgentEvent {\n  CameraChanged = 'cameraChanged',\n  MicrophoneChanged = 'microphoneChanged',\n  StateChanged = 'stateChanged',\n}\n\n/** @beta */\nexport type AgentCallbacks = {\n  [AgentEvent.CameraChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.MicrophoneChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.StateChanged]: (newAgentState: AgentState) => void;\n};\n\ntype AgentStateCommon = {\n  // FIXME: maybe add some sort of schema to this?\n  attributes: Participant['attributes'];\n\n  internal: {\n    emitter: TypedEventEmitter<AgentCallbacks>;\n\n    agentParticipant: RemoteParticipant | null;\n    workerParticipant: RemoteParticipant | null;\n  };\n};\n\ntype AgentStateAvailable = AgentStateCommon & {\n  state: 'listening' | 'thinking' | 'speaking';\n  failureReasons: null;\n\n  /** The agent's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: true;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStatePreConnectBuffering = AgentStateCommon & {\n  state: 'pre-connect-buffering';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateUnAvailable = AgentStateCommon & {\n  state: 'initializing' | 'idle';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: Participant['identity'];\n  name: Participant['name'];\n  metadata: Participant['metadata'];\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateConnecting = AgentStateCommon & {\n  state: 'connecting';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateDisconnected = AgentStateCommon & {\n  state: 'disconnected';\n  failureReasons: null;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateFailed = AgentStateCommon & {\n  state: 'failed';\n  failureReasons: Array<string>;\n\n  /** The client's assigned identity, coming from the JWT token. */\n  identity: undefined;\n  name: undefined;\n  metadata: undefined;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentActions = {\n  /** Returns a promise that resolves once the agent is connected and available for user input */\n  waitUntilConnected: (signal?: AbortSignal) => Promise<void>;\n\n  /**\n   * Returns a promise that resolves once the client could be listening for user speech (`canListen` is true)\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  waitUntilCouldBeListening: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the client has disconnected from the agent either for an expected or unexpected reason. */\n  waitUntilFinished: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the agent has published a camera track */\n  waitUntilCamera: (signal?: AbortSignal) => Promise<TrackReference>;\n\n  /** Returns a promise that resolves once the agent has published a microphone track */\n  waitUntilMicrophone: (signal?: AbortSignal) => Promise<TrackReference>;\n};\n\ntype AgentStateCases =\n  | AgentStateConnecting\n  | AgentStateDisconnected\n  | AgentStateAvailable\n  | AgentStatePreConnectBuffering\n  | AgentStateUnAvailable\n  | AgentStateFailed;\n\n/** @beta */\nexport type UseAgentReturn = AgentStateCases & AgentActions;\n\nconst generateDerivedStateValues = <State extends AgentState>(state: State) =>\n  ({\n    isConnected: state === 'listening' || state === 'thinking' || state === 'speaking',\n    canListen:\n      state === 'pre-connect-buffering' ||\n      state === 'listening' ||\n      state === 'thinking' ||\n      state === 'speaking',\n    isFinished: state === 'disconnected' || state === 'failed',\n    isPending: state === 'connecting' || state === 'initializing' || state === 'idle',\n  }) as {\n    isConnected: State extends 'listening' | 'thinking' | 'speaking' ? true : false;\n    canListen: State extends 'pre-connect-buffering' | 'listening' | 'thinking' | 'speaking'\n      ? true\n      : false;\n    isFinished: State extends 'disconnected' | 'failed' ? true : false;\n    isPending: State extends 'connecting' | 'initializing' | 'idle' ? true : false;\n  };\n\n/** Internal hook used by useSession to store global agent state */\nexport const useAgentTimeoutIdStore = (): {\n  agentTimeoutFailureReason: string | null;\n  startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n  clearAgentTimeout: () => void;\n  clearAgentTimeoutFailureReason: () => void;\n  updateAgentTimeoutState: (agentState: AgentState) => void;\n  updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n} => {\n  const [agentTimeoutFailureReason, setAgentTimeoutFailureReason] = React.useState<string | null>(\n    null,\n  );\n  const [agentTimeoutId, setAgentTimeoutId] = React.useState<ReturnType<typeof setTimeout> | null>(\n    null,\n  );\n\n  const agentStateRef = React.useRef<AgentState>('connecting');\n  const agentParticipantExistsRef = React.useRef(false);\n\n  const startAgentConnectedTimeout = (agentConnectTimeoutMilliseconds?: number) => {\n    return setTimeout(() => {\n      if (!agentParticipantExistsRef.current) {\n        setAgentTimeoutFailureReason('Agent did not join the room.');\n        return;\n      }\n\n      const { isConnected } = generateDerivedStateValues(agentStateRef.current);\n      if (!isConnected) {\n        setAgentTimeoutFailureReason('Agent joined the room but did not complete initializing.');\n        return;\n      }\n    }, agentConnectTimeoutMilliseconds ?? DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS);\n  };\n\n  return {\n    agentTimeoutFailureReason,\n    startAgentTimeout: React.useCallback(\n      (agentConnectTimeoutMilliseconds?: number) => {\n        if (agentTimeoutId) {\n          clearTimeout(agentTimeoutId);\n        }\n\n        setAgentTimeoutFailureReason(null);\n        setAgentTimeoutId(startAgentConnectedTimeout(agentConnectTimeoutMilliseconds));\n        agentStateRef.current = 'connecting';\n        agentParticipantExistsRef.current = false;\n      },\n      [agentTimeoutId],\n    ),\n    clearAgentTimeout: React.useCallback(() => {\n      if (agentTimeoutId) {\n        clearTimeout(agentTimeoutId);\n      }\n\n      setAgentTimeoutFailureReason(null);\n      setAgentTimeoutId(null);\n      agentStateRef.current = 'connecting';\n      agentParticipantExistsRef.current = false;\n    }, [agentTimeoutId]),\n    clearAgentTimeoutFailureReason: React.useCallback(() => {\n      setAgentTimeoutFailureReason(null);\n    }, []),\n\n    updateAgentTimeoutState: React.useCallback((agentState: AgentState) => {\n      agentStateRef.current = agentState;\n    }, []),\n    updateAgentTimeoutParticipantExists: React.useCallback((agentParticipantExists: boolean) => {\n      agentParticipantExistsRef.current = agentParticipantExists;\n    }, []),\n  };\n};\n\ntype SessionStub = Pick<UseSessionReturn, 'connectionState' | 'room' | 'internal'>;\n\n/** Internal hook used by useAgent which generates a function that when called, will return a\n * promise which resolves when agent.isAvailable is enabled. */\nfunction useAgentWaitUntilDerivedStates(\n  emitter: TypedEventEmitter<AgentCallbacks>,\n  state: AgentState,\n) {\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isConnected } = generateDerivedStateValues(stateRef.current);\n      if (isConnected) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isConnected } = generateDerivedStateValues(state);\n          if (!isConnected) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilConnected - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilCouldBeListening = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { canListen } = generateDerivedStateValues(stateRef.current);\n      if (canListen) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { canListen } = generateDerivedStateValues(state);\n          if (!canListen) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCouldBeListening - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilFinished = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isFinished } = generateDerivedStateValues(stateRef.current);\n      if (isFinished) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isFinished } = generateDerivedStateValues(state);\n          if (!isFinished) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilFinished - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished };\n}\n\n/**\n * useAgent encapculates all agent state, normalizing some quirks around how LiveKit Agents work.\n * @beta\n */\nexport function useAgent(session?: SessionStub): UseAgentReturn {\n  const sessionFromContext = useMaybeSessionContext();\n  session = session ?? sessionFromContext;\n  if (!session) {\n    throw new Error(\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\n    );\n  }\n\n  const {\n    room,\n    internal: {\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    },\n  } = session;\n\n  const emitter = React.useMemo(() => new EventEmitter() as TypedEventEmitter<AgentCallbacks>, []);\n\n  const roomRemoteParticipants = useRemoteParticipants({ room });\n\n  const agentParticipant = React.useMemo(() => {\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n      ) ?? null\n    );\n  }, [roomRemoteParticipants]);\n  const workerParticipant = React.useMemo(() => {\n    if (!agentParticipant) {\n      return null;\n    }\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agentParticipant.identity,\n      ) ?? null\n    );\n  }, [agentParticipant, roomRemoteParticipants]);\n\n  // 1. Listen for agent participant attribute changes\n  const [agentParticipantAttributes, setAgentParticipantAttributes] = React.useState<\n    Participant['attributes']\n  >(agentParticipant?.attributes ?? {});\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const handleAttributesChanged = (attributes: UseAgentReturn['attributes']) => {\n      setAgentParticipantAttributes(attributes);\n    };\n\n    agentParticipant.on(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    return () => {\n      agentParticipant.off(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    };\n  }, [agentParticipant, emitter]);\n\n  // 2. Listen for track updates\n  const agentTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: agentParticipant?.identity,\n  });\n  const workerTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: workerParticipant?.identity,\n  });\n\n  const videoTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Camera) ??\n      workerTracks.find((t) => t.source === Track.Source.Camera),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.CameraChanged, videoTrack);\n  }, [emitter, videoTrack]);\n\n  const audioTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n      workerTracks.find((t) => t.source === Track.Source.Microphone),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.MicrophoneChanged, audioTrack);\n  }, [emitter, audioTrack]);\n\n  // Listen for room connection state updates\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  // When the agent participant connects, reset the timeout failure state\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    clearAgentTimeoutFailureReason();\n  }, [agentParticipant]);\n\n  // If the agent participant disconnects in the middle of a conversation unexpectedly, mark that as an explicit failure\n  const [agentDisconnectedFailureReason, setAgentDisconnectedFailureReason] = React.useState<\n    string | null\n  >(null);\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const onParticipantDisconnect = (participant: RemoteParticipant) => {\n      if (participant.identity !== agentParticipant?.identity) {\n        return;\n      }\n      setAgentDisconnectedFailureReason('Agent left the room unexpectedly.');\n    };\n\n    room.on(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n\n    return () => {\n      room.off(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n    };\n  }, [agentParticipant, room]);\n\n  React.useEffect(() => {\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      return;\n    }\n    // Clear the agent disconnect failure state when the room disconnects\n    setAgentDisconnectedFailureReason(null);\n  }, [roomConnectionState]);\n\n  const [localMicTrack, setLocalMicTrack] = React.useState<LocalTrackPublication | null>(\n    () => room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null,\n  );\n  React.useEffect(() => {\n    const handleLocalParticipantTrackPublished = () => {\n      setLocalMicTrack(room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null);\n    };\n    const handleLocalParticipantTrackUnPublished = () => {\n      setLocalMicTrack(null);\n    };\n\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackPublished,\n      handleLocalParticipantTrackPublished,\n    );\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackUnpublished,\n      handleLocalParticipantTrackUnPublished,\n    );\n    return () => {\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackPublished,\n        handleLocalParticipantTrackPublished,\n      );\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackUnpublished,\n        handleLocalParticipantTrackUnPublished,\n      );\n    };\n  }, [room.localParticipant]);\n\n  const failureReasons = React.useMemo(() => {\n    const reasons = [];\n    if (agentTimeoutFailureReason) {\n      reasons.push(agentTimeoutFailureReason);\n    }\n    if (agentDisconnectedFailureReason) {\n      reasons.push(agentDisconnectedFailureReason);\n    }\n    return reasons;\n  }, [agentTimeoutFailureReason, agentDisconnectedFailureReason]);\n\n  const state = React.useMemo(() => {\n    if (failureReasons.length > 0) {\n      return 'failed';\n    }\n\n    let state: AgentState = 'disconnected';\n\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      state = 'connecting';\n    }\n\n    // If the microphone preconnect buffer is active, then a special 'pre-connect-buffering' state\n    // is set\n    if (localMicTrack) {\n      state = 'pre-connect-buffering';\n    }\n\n    if (agentParticipant && agentParticipantAttributes[ParticipantAgentAttributes.AgentState]) {\n      state = agentParticipantAttributes[ParticipantAgentAttributes.AgentState] as AgentSdkStates;\n    }\n\n    return state;\n  }, [\n    failureReasons,\n    roomConnectionState,\n    localMicTrack,\n    agentParticipant,\n    agentParticipantAttributes,\n  ]);\n\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.StateChanged, state);\n    updateAgentTimeoutState(state);\n  }, [emitter, state]);\n  React.useEffect(() => {\n    updateAgentTimeoutParticipantExists(agentParticipant !== null);\n  }, [agentParticipant]);\n\n  // When the session room begins connecting, start the agent timeout\n  const isSessionDisconnected = session.connectionState === 'disconnected';\n  React.useEffect(() => {\n    if (isSessionDisconnected) {\n      return;\n    }\n\n    startAgentTimeout(agentConnectTimeoutMilliseconds);\n    return () => {\n      clearAgentTimeout();\n    };\n  }, [isSessionDisconnected, agentConnectTimeoutMilliseconds]);\n\n  const {\n    identity: agentParticipantIdentity,\n    name: agentParticipantName,\n    metadata: agentParticipantMetadata,\n  } = useParticipantInfo({ participant: agentParticipant ?? undefined });\n\n  const agentState: AgentStateCases = React.useMemo(() => {\n    const common: AgentStateCommon = {\n      attributes: agentParticipantAttributes,\n\n      internal: {\n        agentParticipant,\n        workerParticipant,\n        emitter,\n      },\n    };\n\n    switch (state) {\n      case 'disconnected':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'connecting':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'initializing':\n      case 'idle':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'pre-connect-buffering':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'listening':\n      case 'thinking':\n      case 'speaking':\n        return {\n          ...common,\n          identity: agentParticipantIdentity!,\n          name: agentParticipantName,\n          metadata: agentParticipantMetadata,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'failed':\n        return {\n          ...common,\n          identity: undefined,\n          name: undefined,\n          metadata: undefined,\n\n          state: 'failed',\n          ...generateDerivedStateValues('failed'),\n          failureReasons,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n    }\n  }, [\n    agentParticipantIdentity,\n    agentParticipantName,\n    agentParticipantMetadata,\n    agentParticipantAttributes,\n    emitter,\n    agentParticipant,\n    state,\n    videoTrack,\n    audioTrack,\n  ]);\n\n  const { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished } =\n    useAgentWaitUntilDerivedStates(emitter, state);\n\n  const waitUntilCamera = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (camera: TrackReference | undefined) => {\n          if (!camera) {\n            return;\n          }\n          cleanup();\n          resolve(camera);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCamera - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.CameraChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.CameraChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilMicrophone = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (microphone: TrackReference | undefined) => {\n          if (!microphone) {\n            return;\n          }\n          cleanup();\n          resolve(microphone);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilMicrophone - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.MicrophoneChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.MicrophoneChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return React.useMemo(() => {\n    return {\n      ...agentState,\n      waitUntilConnected,\n      waitUntilCouldBeListening,\n      waitUntilFinished,\n      waitUntilCamera,\n      waitUntilMicrophone,\n    };\n  }, [\n    agentState,\n    waitUntilConnected,\n    waitUntilCouldBeListening,\n    waitUntilFinished,\n    waitUntilCamera,\n    waitUntilMicrophone,\n  ]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport {\n  Room,\n  RoomEvent,\n  ConnectionState,\n  TrackPublishOptions,\n  Track,\n  TokenSourceConfigurable,\n  TokenSourceFixed,\n  TokenSourceFetchOptions,\n  RoomConnectOptions,\n  decodeTokenPayload,\n} from 'livekit-client';\nimport { EventEmitter } from 'events';\n\nimport { useMaybeRoomContext } from '../context';\nimport { AgentState, useAgent, useAgentTimeoutIdStore } from './useAgent';\nimport { TrackReference } from '@livekit/components-core';\nimport { useLocalParticipant } from './useLocalParticipant';\n\n/** @beta */\nexport enum SessionEvent {\n  ConnectionStateChanged = 'connectionStateChanged',\n  /**\n   * Emits when an error is encountered while attempting to create a track.\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * args: (error: Error, kind: MediaDeviceKind)\n   */\n  MediaDevicesError = 'mediaDevicesError',\n  /**\n   * Emits when an error is received while decrypting frame received frame information.\n   * args: (error: Error)\n   */\n  EncryptionError = 'encryptionError',\n}\n\n/** @beta */\nexport type SessionCallbacks = {\n  [SessionEvent.ConnectionStateChanged]: (newAgentConnectionState: ConnectionState) => void;\n  [SessionEvent.MediaDevicesError]: (error: Error) => void;\n  [SessionEvent.EncryptionError]: (error: Error) => void;\n};\n\n/** @beta */\nexport type SessionConnectOptions = {\n  /** Optional abort signal which if triggered will terminate connecting even if it isn't complete */\n  signal?: AbortSignal;\n\n  tracks?: {\n    microphone?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n    camera?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n    screenShare?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n  };\n\n  /** Options for Room.connect(.., .., opts) */\n  roomConnectOptions?: RoomConnectOptions;\n};\n\n/** @beta */\nexport type SwitchActiveDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\ntype SessionStateCommon = {\n  room: Room;\n  internal: {\n    emitter: TypedEventEmitter<SessionCallbacks>;\n    tokenSource: TokenSourceConfigurable | TokenSourceFixed;\n    agentConnectTimeoutMilliseconds?: number;\n\n    agentTimeoutFailureReason: string | null;\n    startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n    clearAgentTimeout: () => void;\n    clearAgentTimeoutFailureReason: () => void;\n    updateAgentTimeoutState: (agentState: AgentState) => void;\n    updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n  };\n};\n\ntype SessionStateConnecting = SessionStateCommon & {\n  connectionState: ConnectionState.Connecting;\n  isConnected: false;\n\n  local: {\n    cameraTrack: undefined;\n    microphoneTrack: undefined;\n    screenShareTrack: undefined;\n  };\n};\n\ntype SessionStateConnected = SessionStateCommon & {\n  connectionState:\n    | ConnectionState.Connected\n    | ConnectionState.Reconnecting\n    | ConnectionState.SignalReconnecting;\n  isConnected: true;\n\n  local: {\n    cameraTrack?: TrackReference;\n    microphoneTrack?: TrackReference;\n    screenShareTrack?: TrackReference;\n  };\n};\n\ntype SessionStateDisconnected = SessionStateCommon & {\n  connectionState: ConnectionState.Disconnected;\n  isConnected: false;\n\n  local: {\n    cameraTrack: undefined;\n    microphoneTrack: undefined;\n    screenShareTrack: undefined;\n  };\n};\n\ntype SessionActions = {\n  /** Returns a promise that resolves once the room connects. */\n  waitUntilConnected: (signal?: AbortSignal) => void;\n  /** Returns a promise that resolves once the room disconnects */\n  waitUntilDisconnected: (signal?: AbortSignal) => void;\n\n  prepareConnection: () => Promise<void>;\n\n  /** Connect to the underlying room and dispatch any agents */\n  start: (options?: SessionConnectOptions) => Promise<void>;\n\n  /** Disconnect from the underlying room */\n  end: () => Promise<void>;\n};\n\n/** @beta */\nexport type UseSessionReturn = (\n  | SessionStateConnecting\n  | SessionStateConnected\n  | SessionStateDisconnected\n) &\n  SessionActions;\n\ntype UseSessionCommonOptions = {\n  room?: Room;\n\n  /**\n   * Amount of time in milliseonds the system will wait for an agent to join the room, before\n   * transitioning to the \"failure\" state.\n   */\n  agentConnectTimeoutMilliseconds?: number;\n};\n\ntype UseSessionConfigurableOptions = UseSessionCommonOptions & TokenSourceFetchOptions;\ntype UseSessionFixedOptions = UseSessionCommonOptions;\n\n/**\n * Given two TokenSourceFetchOptions values, check to see if they are deep equal.\n *\n * FIXME: swap this for an import from livekit-client once\n * https://github.com/livekit/client-sdk-js/pull/1733 is merged and published!\n * */\nfunction areTokenSourceFetchOptionsEqual(a: TokenSourceFetchOptions, b: TokenSourceFetchOptions) {\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]) as Set<\n    keyof TokenSourceFetchOptions\n  >;\n\n  for (const key of allKeysSet) {\n    switch (key) {\n      case 'roomName':\n      case 'participantName':\n      case 'participantIdentity':\n      case 'participantMetadata':\n      case 'participantAttributes':\n      case 'agentName':\n      case 'agentMetadata':\n        if (a[key] !== b[key]) {\n          return false;\n        }\n        break;\n      default:\n        // ref: https://stackoverflow.com/a/58009992\n        const exhaustiveCheckedKey: never = key;\n        throw new Error(`Options key ${exhaustiveCheckedKey} not being checked for equality!`);\n    }\n  }\n\n  return true;\n}\n\n/** Internal hook used by useSession to manage creating a function which can be used to wait\n * until the session is in a given state before resolving. */\nfunction useSessionWaitUntilConnectionState(\n  emitter: TypedEventEmitter<SessionCallbacks>,\n  connectionState: UseSessionReturn['connectionState'],\n) {\n  const connectionStateRef = React.useRef(connectionState);\n  React.useEffect(() => {\n    connectionStateRef.current = connectionState;\n  }, [connectionState]);\n\n  const waitUntilConnectionState = React.useCallback(\n    async (state: UseSessionReturn['connectionState'], signal?: AbortSignal) => {\n      if (connectionStateRef.current === state) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const onceEventOccurred = (newState: UseSessionReturn['connectionState']) => {\n          if (newState !== state) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(\n            new Error(\n              `useSession(/* ... */).waitUntilConnectionState(${state}, /* signal */) - signal aborted`,\n            ),\n          );\n        };\n\n        const cleanup = () => {\n          emitter.off(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return waitUntilConnectionState;\n}\n\n/** Internal hook used by useSession to manage creating a function that properly invokes\n * tokenSource.fetch(...) with any fetch options */\nfunction useSessionTokenSourceFetch(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  unstableRestOptions: Exclude<UseSessionConfigurableOptions, keyof UseSessionCommonOptions>,\n) {\n  const isConfigurable = tokenSource instanceof TokenSourceConfigurable;\n\n  const memoizedTokenFetchOptionsRef = React.useRef<TokenSourceFetchOptions | null>(\n    isConfigurable ? unstableRestOptions : null,\n  );\n\n  React.useEffect(() => {\n    if (!isConfigurable) {\n      memoizedTokenFetchOptionsRef.current = null;\n      return;\n    }\n\n    if (\n      memoizedTokenFetchOptionsRef.current !== null &&\n      areTokenSourceFetchOptionsEqual(memoizedTokenFetchOptionsRef.current, unstableRestOptions)\n    ) {\n      return;\n    }\n\n    memoizedTokenFetchOptionsRef.current = unstableRestOptions;\n  }, [isConfigurable, unstableRestOptions]);\n\n  const tokenSourceFetch = React.useCallback(async () => {\n    if (isConfigurable) {\n      if (!memoizedTokenFetchOptionsRef.current) {\n        throw new Error(\n          `AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!`,\n        );\n      }\n      return tokenSource.fetch(memoizedTokenFetchOptionsRef.current);\n    } else {\n      return tokenSource.fetch();\n    }\n  }, [isConfigurable, tokenSource]);\n\n  return tokenSourceFetch;\n}\n\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceConfigurable,\n  options?: UseSessionConfigurableOptions,\n): UseSessionReturn;\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceFixed,\n  options?: UseSessionFixedOptions,\n): UseSessionReturn;\nexport function useSession(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  options: UseSessionConfigurableOptions | UseSessionFixedOptions = {},\n): UseSessionReturn {\n  const { room: optionsRoom, agentConnectTimeoutMilliseconds, ...restOptions } = options;\n\n  const roomFromContext = useMaybeRoomContext();\n  const room = React.useMemo(\n    () => roomFromContext ?? optionsRoom ?? new Room(),\n    [roomFromContext, optionsRoom],\n  );\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<SessionCallbacks>,\n    [],\n  );\n\n  const generateDerivedConnectionStateValues = React.useCallback(\n    <State extends UseSessionReturn['connectionState']>(connectionState: State) =>\n      ({\n        isConnected:\n          connectionState === ConnectionState.Connected ||\n          connectionState === ConnectionState.Reconnecting ||\n          connectionState === ConnectionState.SignalReconnecting,\n      }) as {\n        isConnected: State extends\n          | ConnectionState.Connected\n          | ConnectionState.Reconnecting\n          | ConnectionState.SignalReconnecting\n          ? true\n          : false;\n      },\n    [],\n  );\n\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  React.useEffect(() => {\n    const handleMediaDevicesError = async (error: Error) => {\n      emitter.emit(SessionEvent.MediaDevicesError, error);\n    };\n\n    room.on(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    return () => {\n      room.off(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    };\n  }, [room, emitter]);\n\n  React.useEffect(() => {\n    const handleEncryptionError = async (error: Error) => {\n      emitter.emit(SessionEvent.EncryptionError, error);\n    };\n\n    room.on(RoomEvent.EncryptionError, handleEncryptionError);\n    return () => {\n      room.off(RoomEvent.EncryptionError, handleEncryptionError);\n    };\n  }, [room, emitter]);\n\n  const { localParticipant } = useLocalParticipant({ room });\n  const cameraPublication = localParticipant.getTrackPublication(Track.Source.Camera);\n  const localCamera = React.useMemo(() => {\n    if (!cameraPublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.Camera,\n      participant: localParticipant,\n      publication: cameraPublication,\n    };\n  }, [localParticipant, cameraPublication]);\n  const microphonePublication = localParticipant.getTrackPublication(Track.Source.Microphone);\n  const localMicrophone = React.useMemo(() => {\n    if (!microphonePublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.Microphone,\n      participant: localParticipant,\n      publication: microphonePublication,\n    };\n  }, [localParticipant, microphonePublication]);\n  const screenSharePublication = localParticipant.getTrackPublication(Track.Source.ScreenShare);\n  const localScreenShare = React.useMemo(() => {\n    if (!screenSharePublication) {\n      return undefined;\n    }\n    return {\n      source: Track.Source.ScreenShare,\n      participant: localParticipant,\n      publication: screenSharePublication,\n    };\n  }, [localParticipant, screenSharePublication]);\n\n  const {\n    agentTimeoutFailureReason,\n    startAgentTimeout,\n    clearAgentTimeout,\n    clearAgentTimeoutFailureReason,\n    updateAgentTimeoutState,\n    updateAgentTimeoutParticipantExists,\n  } = useAgentTimeoutIdStore();\n\n  const sessionInternal: UseSessionReturn['internal'] = React.useMemo(\n    () => ({\n      emitter,\n      tokenSource,\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    }),\n    [\n      emitter,\n      agentConnectTimeoutMilliseconds,\n      tokenSource,\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    ],\n  );\n\n  const conversationState = React.useMemo(():\n    | SessionStateConnecting\n    | SessionStateConnected\n    | SessionStateDisconnected => {\n    const common: SessionStateCommon = {\n      room,\n      internal: sessionInternal,\n    };\n\n    switch (roomConnectionState) {\n      case ConnectionState.Connecting:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Connecting,\n          ...generateDerivedConnectionStateValues(ConnectionState.Connecting),\n\n          local: {\n            cameraTrack: undefined,\n            microphoneTrack: undefined,\n            screenShareTrack: undefined,\n          },\n        };\n\n      case ConnectionState.Connected:\n      case ConnectionState.Reconnecting:\n      case ConnectionState.SignalReconnecting:\n        return {\n          ...common,\n\n          connectionState: roomConnectionState,\n          ...generateDerivedConnectionStateValues(roomConnectionState),\n\n          local: {\n            cameraTrack: localCamera,\n            microphoneTrack: localMicrophone,\n            screenShareTrack: localScreenShare,\n          },\n        };\n\n      case ConnectionState.Disconnected:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Disconnected,\n          ...generateDerivedConnectionStateValues(ConnectionState.Disconnected),\n\n          local: {\n            cameraTrack: undefined,\n            microphoneTrack: undefined,\n            screenShareTrack: undefined,\n          },\n        };\n    }\n  }, [\n    sessionInternal,\n    room,\n    roomConnectionState,\n    localCamera,\n    localMicrophone,\n    generateDerivedConnectionStateValues,\n  ]);\n  React.useEffect(() => {\n    emitter.emit(SessionEvent.ConnectionStateChanged, conversationState.connectionState);\n  }, [emitter, conversationState.connectionState]);\n\n  const waitUntilConnectionState = useSessionWaitUntilConnectionState(\n    emitter,\n    conversationState.connectionState,\n  );\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(\n        ConnectionState.Connected /* FIXME: should I check for other states too? */,\n        signal,\n      );\n    },\n    [waitUntilConnectionState],\n  );\n\n  const waitUntilDisconnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(ConnectionState.Disconnected, signal);\n    },\n    [waitUntilConnectionState],\n  );\n\n  const agent = useAgent(\n    React.useMemo(\n      () => ({\n        connectionState: conversationState.connectionState,\n        room,\n        internal: sessionInternal,\n      }),\n      [conversationState, room, sessionInternal],\n    ),\n  );\n\n  const tokenSourceFetch = useSessionTokenSourceFetch(tokenSource, restOptions);\n\n  const start = React.useCallback(\n    async (connectOptions: SessionConnectOptions = {}) => {\n      const {\n        signal,\n        tracks = { microphone: { enabled: true, publishOptions: { preConnectBuffer: true } } },\n        roomConnectOptions,\n      } = connectOptions;\n\n      await waitUntilDisconnected(signal);\n\n      const onSignalAbort = () => {\n        room.disconnect();\n      };\n      signal?.addEventListener('abort', onSignalAbort);\n\n      let tokenDispatchesAgent = false;\n      await Promise.all([\n        tokenSourceFetch().then(({ serverUrl, participantToken }) => {\n          const participantTokenPayload = decodeTokenPayload(participantToken);\n          const participantTokenAgentDispatchCount =\n            participantTokenPayload.roomConfig?.agents?.length ?? 0;\n          tokenDispatchesAgent = participantTokenAgentDispatchCount > 0;\n\n          return room.connect(serverUrl, participantToken, roomConnectOptions);\n        }),\n\n        // Start microphone (with preconnect buffer) by default\n        tracks.microphone?.enabled\n          ? room.localParticipant.setMicrophoneEnabled(\n              true,\n              undefined,\n              tracks.microphone?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n        tracks.camera?.enabled\n          ? room.localParticipant.setCameraEnabled(\n              true,\n              undefined,\n              tracks.camera?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n        tracks.screenShare?.enabled\n          ? room.localParticipant.setScreenShareEnabled(\n              true,\n              undefined,\n              tracks.screenShare?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n      ]);\n\n      await waitUntilConnected(signal);\n      if (tokenDispatchesAgent) {\n        await agent.waitUntilConnected(signal);\n      }\n\n      signal?.removeEventListener('abort', onSignalAbort);\n    },\n    [room, waitUntilDisconnected, tokenSourceFetch, waitUntilConnected, agent.waitUntilConnected],\n  );\n\n  const end = React.useCallback(async () => {\n    await room.disconnect();\n  }, [room]);\n\n  const prepareConnection = React.useCallback(async () => {\n    const credentials = await tokenSourceFetch();\n    await room.prepareConnection(credentials.serverUrl, credentials.participantToken);\n  }, [tokenSourceFetch, room]);\n  React.useEffect(\n    () => {\n      prepareConnection().catch((err) => {\n        // FIXME: figure out a better logging solution?\n        console.warn('WARNING: Room.prepareConnection failed:', err);\n      });\n    },\n    [\n      /* note: no prepareConnection here, this effect should only ever run once! */\n    ],\n  );\n\n  return React.useMemo(\n    () => ({\n      ...conversationState,\n\n      waitUntilConnected,\n      waitUntilDisconnected,\n\n      prepareConnection,\n      start,\n      end,\n    }),\n    [conversationState, waitUntilConnected, waitUntilDisconnected, prepareConnection, start, end],\n  );\n}\n","import * as React from 'react';\nimport TypedEventEmitter, { EventMap } from 'typed-emitter';\n\n/** @public */\nexport function useEvents<\n  Emitter extends TypedEventEmitter<EventMap>,\n  EmitterEventMap extends Emitter extends TypedEventEmitter<infer EM> ? EM : never,\n  Event extends Parameters<Emitter['on']>[0],\n  Callback extends EmitterEventMap[Event],\n>(\n  instance: Emitter | { internal: { emitter: Emitter } } | null | undefined,\n  event: Event,\n  handlerFn: Callback | undefined,\n  dependencies?: React.DependencyList,\n) {\n  const fallback = React.useMemo(() => () => {}, []);\n  const wrappedCallback = React.useCallback(handlerFn ?? fallback, dependencies ?? []);\n  const callback = dependencies ? wrappedCallback : handlerFn;\n\n  const emitter = React.useMemo(() => {\n    if (!instance) {\n      return null;\n    }\n    if ('internal' in instance) {\n      return instance.internal.emitter;\n    }\n    return instance;\n  }, [instance]);\n\n  React.useEffect(() => {\n    if (!emitter || !callback) {\n      return;\n    }\n    emitter.on(event, callback);\n    return () => {\n      emitter.off(event, callback);\n    };\n  }, [emitter, event, callback]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { SendTextOptions } from 'livekit-client';\nimport { EventEmitter } from 'events';\nimport {\n  ReceivedMessage,\n  ReceivedChatMessage,\n  TextStreamData,\n  ReceivedUserTranscriptionMessage,\n  ReceivedAgentTranscriptionMessage,\n} from '@livekit/components-core';\n\nimport { useAgent } from './useAgent';\nimport { useTranscriptions } from './useTranscriptions';\nimport { useChat } from './useChat';\nimport { UseSessionReturn } from './useSession';\nimport { useEnsureSession } from '../context';\n\n/** @beta */\nexport type UseSessionMessagesReturn = {\n  messages: Array<ReceivedMessage>;\n\n  /** Is a send operation currently in progress? */\n  isSending: boolean;\n\n  send: (message: string, options?: SendTextOptions) => Promise<ReceivedChatMessage>;\n\n  internal: {\n    emitter: TypedEventEmitter<MessagesCallbacks>;\n  };\n};\n\n/** @beta */\nexport enum MessagesEvent {\n  /**\n   * Emits when a new message is received from a participant\n   * args: (message: ReceivedMessage)\n   */\n  MessageReceived = 'messageReceived',\n}\n\n/** @beta */\nexport type MessagesCallbacks = {\n  [MessagesEvent.MessageReceived]: (message: ReceivedMessage) => void;\n};\n\n/** @beta */\nexport function useSessionMessages(session?: UseSessionReturn): UseSessionMessagesReturn {\n  const { room } = useEnsureSession(session);\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<MessagesCallbacks>,\n    [],\n  );\n\n  const agent = useAgent(session);\n\n  const transcriptions: Array<TextStreamData> = useTranscriptions({ room });\n  const chatOptions = React.useMemo(() => ({ room }), [room]);\n  const chat = useChat(chatOptions);\n\n  const transcriptionMessages: Array<\n    ReceivedUserTranscriptionMessage | ReceivedAgentTranscriptionMessage\n  > = React.useMemo(() => {\n    return transcriptions.map((transcription) => {\n      switch (transcription.participantInfo.identity) {\n        case room.localParticipant.identity:\n          return {\n            type: 'userTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: room.localParticipant,\n          };\n\n        case agent.internal.agentParticipant?.identity:\n        case agent.internal.workerParticipant?.identity:\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from:\n              agent.internal.agentParticipant?.identity === transcription.participantInfo.identity\n                ? agent.internal.agentParticipant\n                : agent.internal.workerParticipant!,\n          };\n\n        default:\n          // FIXME: what should happen if an associated participant is not found?\n          //\n          // For now, just assume it is an agent transcription, since maybe it is from an agent\n          // which disconencted from the room or something like that.\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: Array.from(room.remoteParticipants.values()).find(\n              (p) => p.identity === transcription.participantInfo.identity,\n            ),\n          };\n      }\n    });\n  }, [transcriptions, room]);\n\n  const receivedMessages = React.useMemo(() => {\n    const merged: Array<ReceivedMessage> = [...transcriptionMessages, ...chat.chatMessages];\n    return merged;\n  }, [transcriptionMessages, chat.chatMessages]);\n\n  const messageFirstReceivedTimeMapRef = React.useRef(new Map<ReceivedMessage['id'], Date>());\n  const sortedReceivedMessages = React.useMemo(() => {\n    const now = new Date();\n    for (const message of receivedMessages) {\n      if (messageFirstReceivedTimeMapRef.current.has(message.id)) {\n        continue;\n      }\n\n      messageFirstReceivedTimeMapRef.current.set(message.id, now);\n    }\n\n    return receivedMessages.sort((a, b) => {\n      const aFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(a.id);\n      const bFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(b.id);\n      if (typeof aFirstReceivedAt === 'undefined' || typeof bFirstReceivedAt === 'undefined') {\n        return 0;\n      }\n\n      return aFirstReceivedAt.getTime() - bFirstReceivedAt.getTime();\n    });\n  }, [receivedMessages]);\n\n  const previouslyReceivedMessageIdsRef = React.useRef(new Set());\n  React.useEffect(() => {\n    for (const message of sortedReceivedMessages) {\n      if (previouslyReceivedMessageIdsRef.current.has(message.id)) {\n        continue;\n      }\n\n      previouslyReceivedMessageIdsRef.current.add(message.id);\n      emitter.emit(MessagesEvent.MessageReceived, message);\n    }\n  }, [sortedReceivedMessages]);\n\n  return React.useMemo(\n    () => ({\n      messages: sortedReceivedMessages,\n      send: chat.send,\n      isSending: chat.isSending,\n      internal: { emitter },\n    }),\n    [sortedReceivedMessages, chat.send, chat.isSending],\n  );\n}\n"],"names":["useLatest","current","storedValue","React","useResizeObserver","target","callback","resizeObserver","getResizeObserver","storedCallback","didUnsubscribe","targetEl","cb","entry","observer","createResizeObserver","ticking","allEntries","callbacks","entries","obs","triggered","i","cbs","cbIndex","_resizeObserver","useSize","size","setSize","width","height","resizeCallback","useObservableState","observable","startWith","resetWhenObservableChanges","state","setState","subscription","useMediaQuery","query","getMatches","matches","setMatches","handleChange","matchMedia","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","roomAudioPlaybackAllowedObservable","canPlayAudio","useClearPinButton","props","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useConnectionQualityIndicator","options","p","useEnsureParticipant","connectionQualityObserver","setupConnectionQualityIndicator","quality","useConnectionState","r","connectionStateObserver","useDataChannel","topicOrCallback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","useDisconnectButton","connectionState","disconnect","setupDisconnectButton","ConnectionState","useFacingMode","trackReference","LocalTrackPublication","localTrack","facingMode","facingModeFromLocalTrack","useFocusToggle","trackRef","useEnsureTrackRef","layoutContext","useMaybeLayoutContext","setupFocusToggle","inFocus","isTrackReferencePinned","event","_a","_c","_b","_e","_d","useGridLayout","gridElement","trackCount","gridLayouts","GRID_LAYOUTS","layout","selectGridLayout","useIsMuted","sourceOrTrackRef","passedParticipant","ref","isMuted","setIsMuted","listener","mutedObserver","getTrackReferenceId","useIsSpeaking","participant","createIsSpeakingObserver","useLocalParticipant","localParticipant","setLocalParticipant","isMicrophoneEnabled","setIsMicrophoneEnabled","isCameraEnabled","setIsCameraEnabled","isScreenShareEnabled","setIsScreenShareEnabled","lastMicrophoneError","setLastMicrophoneError","lastCameraError","setLastCameraError","microphoneTrack","setMicrophoneTrack","cameraTrack","setCameraTrack","handleUpdate","media","observeParticipantMedia","useLocalParticipantPermissions","permissionObserver","participantPermissionObserver","useMediaDeviceSelect","kind","track","requestPermissions","onError","roomContext","useMaybeRoomContext","roomFallback","Room","deviceObserver","createMediaDeviceObserver","devices","currentDeviceId","setCurrentDeviceId","activeDeviceObservable","setActiveMediaDevice","setupDeviceSelector","deviceId","log","useMediaDevices","useVisualStableUpdate","trackReferences","maxItemsOnPage","lastTrackRefs","lastMaxItemsOnPage","layoutChanged","sortedTrackRefs","sortTrackReferences","updatedTrackRefs","updatePages","error","usePagination","itemPerPage","currentPage","setCurrentPage","totalPageCount","lastItemIndex","firstItemIndex","changePage","direction","goToPage","num","tracksOnPage","useParticipantInfo","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useParticipantTile","onParticipantClick","disableSpeakingIndicator","htmlProps","mergedProps","setupParticipantTile","micTrack","Track","micRef","isVideoMuted","isAudioMuted","isSpeaking","useRemoteParticipants","participants","setParticipants","connectedParticipantsObserver","useParticipants","remoteParticipants","usePinnedTracks","useEnsureLayoutContext","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","ensuredRoom","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useStartAudio","handleStartAudioPlayback","setupStartAudio","useStartVideo","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","setupStartVideo","canPlayVideo","useSwipe","element","touchStart","touchEnd","minSwipeDistance","onTouchStart","onTouchMove","onTouchEnd","distance","isLeftSwipe","isRightSwipe","elementCopy","useChatToggle","setupChatToggle","useToken","tokenEndpoint","roomName","token","setToken","params","res","accessToken","useTrackMutedIndicator","mediaMutedObserver","setupTrackMutedIndicator","useTrackToggle","source","onChange","initialState","captureOptions","publishOptions","onDeviceError","rest","roomFromContext","userInteractionRef","toggle","pendingObserver","enabledObserver","setupMediaToggle","setupManualToggle","pending","enabled","newProps","clickHandler","evt","useTracks","sources","setTrackReferences","sources_","s","isSourceWitOptions","trackReferencesObservable","isSourcesWithOptions","requirePlaceholder","requiredPlaceholders","trackReferencesWithPlaceholders","placeholderSource","publication","placeholder","difference","setA","setB","_difference","elem","placeholderMap","sourcesThatNeedPlaceholder","sourceWithOption","sourcesOfSubscribedTracks","pub","trackSource","placeholderNeededForThisParticipant","useTrackRefBySourceOrName","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","useTrackByName","useChat","isDisconnected","setup","setupChat","chatMessages","usePersistentUserChoices","userChoices","setSettings","loadUserChoices","saveAudioInputEnabled","isEnabled","prev","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","username","saveUserChoices","useIsEncrypted","encryptionStatusObservable","useTrackVolume","trackOrTrackReference","isTrackReference","volume","setVolume","cleanup","analyser","createAudioAnalyser","bufferLength","dataArray","interval","sum","a","normalizeFrequencies","frequencies","normalizeDb","value","db","multibandDefaults","useMultibandTrackVolume","opts","frequencyBands","setFrequencyBands","val","normalizedFrequencies","totalBins","chunks","startIndex","endIndex","chunk","chunkLength","summedVolumes","acc","waveformDefaults","useAudioWaveform","aggregateWave","timeRef","updates","bars","setBars","onUpdate","wave","filterData","v","getFFTSizeValue","update","updateWaveform","newData","x","pow2ceil","audioData","numSamples","blockSize","filteredData","blockStart","j","useParticipantTracks","optionsOrParticipantIdentity","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","trackSyncTimeObserver","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","addTimestampsToTranscription","trackTranscriptionObserver","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","state_attribute","ParticipantAgentAttributes","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","attributes","useIsRecording","recordingStatusObservable","useTextStream","textStreamData","setupTextStream","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream","CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY","CONNECT_DISCONNECT_WARNING_THRESHOLD_MS","ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY","ROOM_CHANGE_WARNING_THRESHOLD_MS","useSequentialRoomConnectDisconnect","connectDisconnectQueueRef","useRef","processConnectsAndDisconnectsLock","useMemo","Mutex","processConnectsAndDisconnects","useCallback","unlock","roomChangedTimesRef","checkRoomThreshold","now","roomChangesInThreshold","isWithinThreshold","useEffect","connectDisconnectEnqueueTimes","checkConnectDisconnectThreshold","connectDisconnectsInThreshold","connect","args","resolve","reject","R","ReflectApply","receiver","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","arg","n","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","key","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","index","ret","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS","AgentEvent","generateDerivedStateValues","useAgentTimeoutIdStore","agentTimeoutFailureReason","setAgentTimeoutFailureReason","agentTimeoutId","setAgentTimeoutId","agentStateRef","agentParticipantExistsRef","startAgentConnectedTimeout","agentConnectTimeoutMilliseconds","isConnected","agentState","agentParticipantExists","useAgentWaitUntilDerivedStates","stateRef","waitUntilConnected","signal","stateChangedHandler","abortHandler","waitUntilCouldBeListening","canListen","waitUntilFinished","isFinished","useAgent","session","sessionFromContext","useMaybeSessionContext","startAgentTimeout","clearAgentTimeout","clearAgentTimeoutFailureReason","updateAgentTimeoutState","updateAgentTimeoutParticipantExists","roomRemoteParticipants","agentParticipant","workerParticipant","agentParticipantAttributes","setAgentParticipantAttributes","handleAttributesChanged","ParticipantEvent","roomConnectionState","setRoomConnectionState","handleConnectionStateChanged","RoomEvent","agentDisconnectedFailureReason","setAgentDisconnectedFailureReason","onParticipantDisconnect","localMicTrack","setLocalMicTrack","handleLocalParticipantTrackPublished","handleLocalParticipantTrackUnPublished","failureReasons","reasons","isSessionDisconnected","agentParticipantIdentity","agentParticipantName","agentParticipantMetadata","common","waitUntilCamera","camera","waitUntilMicrophone","microphone","SessionEvent","areTokenSourceFetchOptionsEqual","b","allKeysSet","exhaustiveCheckedKey","useSessionWaitUntilConnectionState","connectionStateRef","onceEventOccurred","newState","useSessionTokenSourceFetch","tokenSource","unstableRestOptions","isConfigurable","TokenSourceConfigurable","memoizedTokenFetchOptionsRef","useSession","optionsRoom","restOptions","generateDerivedConnectionStateValues","handleMediaDevicesError","handleEncryptionError","cameraPublication","localCamera","microphonePublication","localMicrophone","screenSharePublication","localScreenShare","sessionInternal","conversationState","waitUntilConnectionState","waitUntilDisconnected","tokenSourceFetch","start","connectOptions","tracks","roomConnectOptions","onSignalAbort","tokenDispatchesAgent","serverUrl","participantToken","decodeTokenPayload","_f","end","prepareConnection","credentials","useEvents","instance","handlerFn","dependencies","fallback","wrappedCallback","MessagesEvent","useSessionMessages","useEnsureSession","transcriptions","chatOptions","chat","transcriptionMessages","transcription","receivedMessages","messageFirstReceivedTimeMapRef","sortedReceivedMessages","aFirstReceivedAt","bFirstReceivedAt","previouslyReceivedMessageIdsRef"],"mappings":"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","x_google_ignoreList":[53]}