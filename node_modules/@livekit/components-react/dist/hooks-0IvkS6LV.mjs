import * as s from "react";
import { useRef as ue, useMemo as Be, useCallback as ne, useEffect as Ve } from "react";
import { u as U, r as qe, a as De, b as je, c as Y, d as We, e as ze, f as ce, g as Ge, h as Je, i as fe, j as $e, k as Qe, m as Ke, G as Ye, n as Xe, o as Ze, p as me, q as et, t as tt, v as Ie, w as pe, x as Ne, y as nt, l as j, z as rt, A as st, B as he, C as ot, D as at, E as it, F as ct, H as ut, I as dt, J as lt, K as ft, M as Te, N as mt, O as pt, P as ht, Q as bt, S as vt, T as gt, U as St, V as yt, W as _e, X as Ct, Y as Mt, Z as Tt, _ as Et, $ as kt, a0 as wt, a1 as Pt, a2 as Lt, a3 as At, a4 as Rt, a5 as Ot, a6 as Dt, a7 as le, a8 as $, a9 as It, aa as Nt, ab as _t, ac as Ft, ad as xt } from "./contexts-CsO1QZ3r.mjs";
import { m as Q } from "./room-Bb6uLxS5.mjs";
import { ConnectionState as I, LocalTrackPublication as Ut, facingModeFromLocalTrack as Ht, Room as Fe, Track as E, createAudioAnalyser as be, ParticipantKind as ae, Mutex as Bt, ParticipantEvent as ee, RoomEvent as V, decodeTokenPayload as Vt, TokenSourceConfigurable as qt } from "livekit-client";
const jt = (e) => {
  const n = s.useRef(e);
  return s.useEffect(() => {
    n.current = e;
  }), n;
};
function Wt(e, n) {
  const t = Gt(), r = jt(n);
  return s.useLayoutEffect(() => {
    let o = !1;
    const i = e.current;
    if (!i) return;
    function a(c, u) {
      o || r.current(c, u);
    }
    return t == null || t.subscribe(i, a), () => {
      o = !0, t == null || t.unsubscribe(i, a);
    };
  }, [e.current, t, r]), t == null ? void 0 : t.observer;
}
function zt() {
  let e = !1, n = [];
  const t = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const r = new ResizeObserver((o, i) => {
    n = n.concat(o), e || window.requestAnimationFrame(() => {
      const a = /* @__PURE__ */ new Set();
      for (let c = 0; c < n.length; c++) {
        if (a.has(n[c].target)) continue;
        a.add(n[c].target);
        const u = t.get(n[c].target);
        u == null || u.forEach((p) => p(n[c], i));
      }
      n = [], e = !1;
    }), e = !0;
  });
  return {
    observer: r,
    subscribe(o, i) {
      r.observe(o);
      const a = t.get(o) ?? [];
      a.push(i), t.set(o, a);
    },
    unsubscribe(o, i) {
      const a = t.get(o) ?? [];
      if (a.length === 1) {
        r.unobserve(o), t.delete(o);
        return;
      }
      const c = a.indexOf(i);
      c !== -1 && a.splice(c, 1), t.set(o, a);
    }
  };
}
let de;
const Gt = () => de || (de = zt()), Jt = (e) => {
  const [n, t] = s.useState({ width: 0, height: 0 });
  s.useLayoutEffect(() => {
    if (e.current) {
      const { width: o, height: i } = e.current.getBoundingClientRect();
      t({ width: o, height: i });
    }
  }, [e.current]);
  const r = s.useCallback(
    (o) => t(o.contentRect),
    []
  );
  return Wt(e, r), n;
};
function O(e, n, t = !0) {
  const [r, o] = s.useState(n);
  return s.useEffect(() => {
    if (t && o(n), typeof window > "u" || !e) return;
    const i = e.subscribe(o);
    return () => i.unsubscribe();
  }, [e, t]), r;
}
function Dn(e) {
  const n = (i) => typeof window < "u" ? window.matchMedia(i).matches : !1, [t, r] = s.useState(n(e));
  function o() {
    r(n(e));
  }
  return s.useEffect(() => {
    const i = window.matchMedia(e);
    return o(), i.addListener ? i.addListener(o) : i.addEventListener("change", o), () => {
      i.removeListener ? i.removeListener(o) : i.removeEventListener("change", o);
    };
  }, [e]), t;
}
function In(e) {
  const n = U(e), t = s.useCallback(async () => {
    await n.startAudio();
  }, [n]), r = s.useMemo(
    () => qe(n),
    [n]
  ), { canPlayAudio: o } = O(r, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { canPlayAudio: o, startAudio: t };
}
function Nn(e) {
  const { state: n, dispatch: t } = De().pin;
  return { buttonProps: s.useMemo(() => {
    const { className: o } = je();
    return Q(e, {
      className: o,
      disabled: !(n != null && n.length),
      onClick: () => {
        t && t({ msg: "clear_pin" });
      }
    });
  }, [e, t, n]) };
}
function _n(e = {}) {
  const n = Y(e.participant), { className: t, connectionQualityObserver: r } = s.useMemo(
    () => We(n),
    [n]
  ), o = O(r, n.connectionQuality);
  return { className: t, quality: o };
}
function re(e) {
  const n = U(e), t = s.useMemo(() => ze(n), [n]);
  return O(t, n.state);
}
function Fn(e, n) {
  const t = typeof e == "function" ? e : n, r = typeof e == "string" ? e : void 0, o = ce(), { send: i, messageObservable: a, isSendingObservable: c } = s.useMemo(
    () => Ge(o, r, t),
    [o, r, t]
  ), u = O(a, void 0), p = O(c, !1);
  return {
    message: u,
    send: i,
    isSending: p
  };
}
function xn(e) {
  const n = ce(), t = re(n);
  return { buttonProps: s.useMemo(() => {
    const { className: o, disconnect: i } = Je(n);
    return Q(e, {
      className: o,
      onClick: () => i(e.stopTracks ?? !0),
      disabled: t === I.Disconnected
    });
  }, [n, e, t]) };
}
function $t(e) {
  if (e.publication instanceof Ut) {
    const n = e.publication.track;
    if (n) {
      const { facingMode: t } = Ht(n);
      return t;
    }
  }
  return "undefined";
}
function Un({ trackRef: e, props: n }) {
  const t = fe(e), r = $e(), { className: o } = s.useMemo(() => Qe(), []), i = s.useMemo(() => Ke(t, r == null ? void 0 : r.pin.state), [t, r == null ? void 0 : r.pin.state]);
  return { mergedProps: s.useMemo(
    () => Q(n, {
      className: o,
      onClick: (c) => {
        var u, p, h, l, d;
        (u = n.onClick) == null || u.call(n, c), i ? (h = r == null ? void 0 : (p = r.pin).dispatch) == null || h.call(p, {
          msg: "clear_pin"
        }) : (d = r == null ? void 0 : (l = r.pin).dispatch) == null || d.call(l, {
          msg: "set_pin",
          trackReference: t
        });
      }
    }),
    [n, o, t, i, r == null ? void 0 : r.pin]
  ), inFocus: i };
}
function Hn(e, n, t = {}) {
  const r = t.gridLayouts ?? Ye, { width: o, height: i } = Jt(e), a = Xe(r, n, o, i);
  return s.useEffect(() => {
    e.current && a && (e.current.style.setProperty("--lk-col-count", a == null ? void 0 : a.columns.toString()), e.current.style.setProperty("--lk-row-count", a == null ? void 0 : a.rows.toString()));
  }, [e, a]), {
    layout: a,
    containerWidth: o,
    containerHeight: i
  };
}
function Ee(e, n = {}) {
  var c, u;
  const t = typeof e == "string" ? n.participant : e.participant, r = Y(t), o = typeof e == "string" ? { participant: r, source: e } : e, [i, a] = s.useState(
    !!((c = o.publication) != null && c.isMuted || (u = r.getTrackPublication(o.source)) != null && u.isMuted)
  );
  return s.useEffect(() => {
    const p = Ze(o).subscribe(a);
    return () => p.unsubscribe();
  }, [me(o)]), i;
}
function Qt(e) {
  const n = Y(e), t = s.useMemo(() => et(n), [n]);
  return O(t, n.isSpeaking);
}
function xe(e = {}) {
  const n = U(e.room), [t, r] = s.useState(n.localParticipant), [o, i] = s.useState(
    t.isMicrophoneEnabled
  ), [a, c] = s.useState(t.isCameraEnabled), [u, p] = s.useState(
    t.isScreenShareEnabled
  ), [h, l] = s.useState(
    t.lastMicrophoneError
  ), [d, v] = s.useState(t.lastCameraError), [M, w] = s.useState(
    void 0
  ), [A, P] = s.useState(void 0), D = (R) => {
    c(R.isCameraEnabled), i(R.isMicrophoneEnabled), p(R.isScreenShareEnabled), P(R.cameraTrack), w(R.microphoneTrack), l(R.participant.lastMicrophoneError), v(R.participant.lastCameraError), r(R.participant);
  };
  return s.useEffect(() => {
    const R = tt(n.localParticipant).subscribe(D);
    return () => R.unsubscribe();
  }, [n]), {
    isMicrophoneEnabled: o,
    isScreenShareEnabled: u,
    isCameraEnabled: a,
    microphoneTrack: M,
    cameraTrack: A,
    lastMicrophoneError: h,
    lastCameraError: d,
    localParticipant: t
  };
}
function Bn() {
  const e = ce(), n = s.useMemo(
    () => Ie(e.localParticipant),
    [e]
  );
  return O(n, e.localParticipant.permissions);
}
function Vn({
  kind: e,
  room: n,
  track: t,
  requestPermissions: r,
  onError: o
}) {
  const i = pe(), a = s.useMemo(() => n ?? i ?? new Fe(), [n, i]), c = s.useMemo(
    () => Ne(e, o, r),
    [e, r, o]
  ), u = O(c, []), [p, h] = s.useState(
    (a == null ? void 0 : a.getActiveDevice(e)) ?? "default"
  ), { className: l, activeDeviceObservable: d, setActiveMediaDevice: v } = s.useMemo(
    () => nt(e, a),
    [e, a, t]
  );
  return s.useEffect(() => {
    const M = d.subscribe((w) => {
      w && (j.info("setCurrentDeviceId", w), h(w));
    });
    return () => {
      M == null || M.unsubscribe();
    };
  }, [d]), { devices: u, className: l, activeDeviceId: p, setActiveMediaDevice: v };
}
function qn({
  kind: e,
  onError: n
}) {
  const t = s.useMemo(
    () => Ne(e, n),
    [e, n]
  );
  return O(t, []);
}
function Kt(e, n, t = {}) {
  const r = s.useRef([]), o = s.useRef(-1), i = n !== o.current, a = typeof t.customSortFunction == "function" ? t.customSortFunction(e) : rt(e);
  let c = [...a];
  if (i === !1)
    try {
      c = st(r.current, a, n);
    } catch (u) {
      j.error("Error while running updatePages(): ", u);
    }
  return i ? r.current = a : r.current = c, o.current = n, c;
}
function jn(e, n) {
  const [t, r] = s.useState(1), o = Math.max(Math.ceil(n.length / e), 1);
  t > o && r(o);
  const i = t * e, a = i - e, c = (l) => {
    r((d) => l === "next" ? d === o ? d : d + 1 : d === 1 ? d : d - 1);
  }, u = (l) => {
    l > o ? r(o) : l < 1 ? r(1) : r(l);
  }, h = Kt(n, e).slice(a, i);
  return {
    totalPageCount: o,
    nextPage: () => c("next"),
    prevPage: () => c("previous"),
    setPage: u,
    firstItemIndex: a,
    lastItemIndex: i,
    tracks: h,
    currentPage: t
  };
}
function Yt(e = {}) {
  let n = he();
  e.participant && (n = e.participant);
  const t = s.useMemo(() => ot(n), [n]), { identity: r, name: o, metadata: i } = O(t, {
    name: n == null ? void 0 : n.name,
    identity: n == null ? void 0 : n.identity,
    metadata: n == null ? void 0 : n.metadata
  });
  return { identity: r, name: o, metadata: i };
}
function Wn(e = {}) {
  const n = Y(e.participant), t = s.useMemo(() => Ie(n), [n]);
  return O(t, n.permissions);
}
function zn({
  trackRef: e,
  onParticipantClick: n,
  disableSpeakingIndicator: t,
  htmlProps: r
}) {
  const o = fe(e), i = s.useMemo(() => {
    const { className: d } = at();
    return Q(r, {
      className: d,
      onClick: (v) => {
        var M;
        if ((M = r.onClick) == null || M.call(r, v), typeof n == "function") {
          const w = o.publication ?? o.participant.getTrackPublication(o.source);
          n({ participant: o.participant, track: w });
        }
      }
    });
  }, [
    r,
    n,
    o.publication,
    o.source,
    o.participant
  ]), a = o.participant.getTrackPublication(E.Source.Microphone), c = s.useMemo(() => ({
    participant: o.participant,
    source: E.Source.Microphone,
    publication: a
  }), [a, o.participant]), u = Ee(o), p = Ee(c), h = Qt(o.participant), l = $t(o);
  return {
    elementProps: {
      "data-lk-audio-muted": p,
      "data-lk-video-muted": u,
      "data-lk-speaking": t === !0 ? !1 : h,
      "data-lk-local-participant": o.participant.isLocal,
      "data-lk-source": o.source,
      "data-lk-facing-mode": l,
      ...i
    }
  };
}
function ve(e = {}) {
  const n = U(e.room), [t, r] = s.useState([]);
  return s.useEffect(() => {
    const o = it(n, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(r);
    return () => o.unsubscribe();
  }, [n, JSON.stringify(e.updateOnlyOn)]), t;
}
function Xt(e = {}) {
  const n = ve(e), { localParticipant: t } = xe(e);
  return s.useMemo(
    () => [t, ...n],
    [t, n]
  );
}
function Gn(e) {
  return e = ct(e), s.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Jn(e, n = {}) {
  const t = ce(), [r] = s.useState(n.updateOnlyOn), o = s.useMemo(() => typeof e == "string" ? ut(t, e, {
    additionalEvents: r
  }) : dt(t, e, {
    additionalEvents: r
  }), [t, JSON.stringify(e), r]), [i, a] = s.useState({
    p: void 0
  });
  return s.useEffect(() => {
    const c = o.subscribe((u) => a({ p: u }));
    return () => c.unsubscribe();
  }, [o]), i.p;
}
function $n(e = {}) {
  const n = U(e.room), t = s.useMemo(() => lt(n), [n]), { name: r, metadata: o } = O(t, {
    name: n.name,
    metadata: n.metadata
  });
  return { name: r, metadata: o };
}
function Zt(e) {
  const n = U(e == null ? void 0 : e.room), t = s.useMemo(() => ft(n), [n]);
  return O(t, n.activeSpeakers);
}
function Qn(e) {
  const [n, t] = s.useState(
    Te(e)
  ), r = Zt();
  return s.useEffect(() => {
    t(Te(e));
  }, [r, e]), n;
}
function Kn({ room: e, props: n }) {
  const t = U(e), { className: r, roomAudioPlaybackAllowedObservable: o, handleStartAudioPlayback: i } = s.useMemo(
    () => mt(),
    []
  ), a = s.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayAudio: c } = O(a, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { mergedProps: s.useMemo(
    () => Q(n, {
      className: r,
      onClick: () => {
        i(t);
      },
      style: { display: c ? "none" : "block" }
    }),
    [n, r, c, i, t]
  ), canPlayAudio: c };
}
function Yn({ room: e, props: n }) {
  const t = U(e), { className: r, roomVideoPlaybackAllowedObservable: o, handleStartVideoPlayback: i } = s.useMemo(
    () => pt(),
    []
  ), a = s.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayVideo: c } = O(a, {
    canPlayVideo: t.canPlaybackVideo
  });
  return { mergedProps: s.useMemo(
    () => Q(n, {
      className: r,
      onClick: () => {
        i(t);
      },
      style: { display: c ? "none" : "block" }
    }),
    [n, r, c, i, t]
  ), canPlayVideo: c };
}
function Xn(e, n = {}) {
  const t = s.useRef(null), r = s.useRef(null), o = n.minSwipeDistance ?? 50, i = (u) => {
    r.current = null, t.current = u.targetTouches[0].clientX;
  }, a = (u) => {
    r.current = u.targetTouches[0].clientX;
  }, c = s.useCallback(() => {
    if (!t.current || !r.current)
      return;
    const u = t.current - r.current, p = u > o, h = u < -o;
    p && n.onLeftSwipe && n.onLeftSwipe(), h && n.onRightSwipe && n.onRightSwipe();
  }, [o, n]);
  s.useEffect(() => {
    const u = e.current;
    return u && (u.addEventListener("touchstart", i, { passive: !0 }), u.addEventListener("touchmove", a, { passive: !0 }), u.addEventListener("touchend", c, { passive: !0 })), () => {
      u && (u.removeEventListener("touchstart", i), u.removeEventListener("touchmove", a), u.removeEventListener("touchend", c));
    };
  }, [e, c]);
}
function Zn({ props: e }) {
  const { dispatch: n, state: t } = De().widget, { className: r } = s.useMemo(() => ht(), []);
  return { mergedProps: s.useMemo(() => Q(e, {
    className: r,
    onClick: () => {
      n && n({ msg: "toggle_chat" });
    },
    "aria-pressed": t != null && t.showChat ? "true" : "false",
    "data-lk-unread-msgs": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, r, n, t]) };
}
function er(e, n, t = {}) {
  const [r, o] = s.useState(void 0);
  return s.useEffect(() => {
    var a;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((a = t.userInfo) == null ? void 0 : a.identity) === void 0)
      return;
    (async () => {
      j.debug("fetching token");
      const c = new URLSearchParams({ ...t.userInfo, roomName: n }), u = await fetch(`${e}?${c.toString()}`);
      if (!u.ok) {
        j.error(
          `Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`
        );
        return;
      }
      const { accessToken: p } = await u.json();
      o(p);
    })();
  }, [e, n, JSON.stringify(t)]), r;
}
function tr(e) {
  var i, a;
  const n = fe(e), { className: t, mediaMutedObserver: r } = s.useMemo(
    () => bt(n),
    [me(n)]
  );
  return { isMuted: O(
    r,
    !!((i = n.publication) != null && i.isMuted || (a = n.participant.getTrackPublication(n.source)) != null && a.isMuted)
  ), className: t };
}
function nr({
  source: e,
  onChange: n,
  initialState: t,
  captureOptions: r,
  publishOptions: o,
  onDeviceError: i,
  room: a,
  ...c
}) {
  var m;
  const u = pe(), p = s.useMemo(() => a ?? u, [a, u]), h = (m = p == null ? void 0 : p.localParticipant) == null ? void 0 : m.getTrackPublication(e), l = s.useRef(!1), { toggle: d, className: v, pendingObserver: M, enabledObserver: w } = s.useMemo(
    () => p ? vt(e, p, r, o, i) : gt(),
    [p, e, JSON.stringify(r), o]
  ), A = O(M, !1), P = O(w, t ?? !!(h != null && h.isEnabled));
  s.useEffect(() => {
    n == null || n(P, l.current), l.current = !1;
  }, [P, n]), s.useEffect(() => {
    t !== void 0 && (j.debug("forcing initial toggle state", e, t), d(t));
  }, []);
  const D = s.useMemo(() => Q(c, { className: v }), [c, v]), R = s.useCallback(
    (f) => {
      var b;
      l.current = !0, d().catch(() => l.current = !1), (b = c.onClick) == null || b.call(c, f);
    },
    [c, d]
  );
  return {
    toggle: d,
    enabled: P,
    pending: A,
    track: h,
    buttonProps: {
      ...D,
      "aria-pressed": P,
      "data-lk-source": e,
      "data-lk-enabled": P,
      disabled: A,
      onClick: R
    }
  };
}
function rr(e = [
  E.Source.Camera,
  E.Source.Microphone,
  E.Source.ScreenShare,
  E.Source.ScreenShareAudio,
  E.Source.Unknown
], n = {}) {
  const t = U(n.room), [r, o] = s.useState([]), [i, a] = s.useState([]), c = s.useMemo(() => e.map((p) => St(p) ? p.source : p), [JSON.stringify(e)]);
  return s.useEffect(() => {
    const p = yt(t, c, {
      additionalRoomEvents: n.updateOnlyOn,
      onlySubscribed: n.onlySubscribed
    }).subscribe(({ trackReferences: h, participants: l }) => {
      j.debug("setting track bundles", h, l), o(h), a(l);
    });
    return () => p.unsubscribe();
  }, [
    t,
    JSON.stringify(n.onlySubscribed),
    JSON.stringify(n.updateOnlyOn),
    JSON.stringify(e)
  ]), s.useMemo(() => {
    if (_e(e)) {
      const p = tn(e, i), h = Array.from(r);
      return i.forEach((l) => {
        p.has(l.identity) && (p.get(l.identity) ?? []).forEach((v) => {
          if (r.find(
            ({ participant: w, publication: A }) => l.identity === w.identity && A.source === v
          ))
            return;
          j.debug(
            `Add ${v} placeholder for participant ${l.identity}.`
          );
          const M = {
            participant: l,
            source: v
          };
          h.push(M);
        });
      }), h;
    } else
      return r;
  }, [r, i, e]);
}
function en(e, n) {
  const t = new Set(e);
  for (const r of n)
    t.delete(r);
  return t;
}
function tn(e, n) {
  const t = /* @__PURE__ */ new Map();
  if (_e(e)) {
    const r = e.filter((o) => o.withPlaceholder).map((o) => o.source);
    n.forEach((o) => {
      const i = o.getTrackPublications().map((c) => {
        var u;
        return (u = c.track) == null ? void 0 : u.source;
      }).filter((c) => c !== void 0), a = Array.from(
        en(new Set(r), new Set(i))
      );
      a.length > 0 && t.set(o.identity, a);
    });
  }
  return t;
}
function nn(e) {
  const [n, t] = s.useState(Ct(e)), { trackObserver: r } = s.useMemo(() => Mt(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return s.useEffect(() => {
    const o = r.subscribe((i) => {
      t(i);
    });
    return () => o == null ? void 0 : o.unsubscribe();
  }, [r]), {
    participant: e.participant,
    source: e.source ?? E.Source.Unknown,
    publication: n
  };
}
function sr(e, n) {
  const t = Y(n);
  return nn({ name: e, participant: t });
}
function rn(e) {
  const n = U(e == null ? void 0 : e.room), t = re(n), r = s.useMemo(
    () => t === I.Disconnected,
    [t]
  ), o = s.useMemo(
    () => Tt(n, e),
    [n, e, r]
  ), i = O(o.isSendingObservable, !1), a = O(o.messageObservable, []);
  return { send: o.send, chatMessages: a, isSending: i };
}
function or(e = {}) {
  const [n, t] = s.useState(
    Et(e.defaults, e.preventLoad ?? !1)
  ), r = s.useCallback((u) => {
    t((p) => ({ ...p, audioEnabled: u }));
  }, []), o = s.useCallback((u) => {
    t((p) => ({ ...p, videoEnabled: u }));
  }, []), i = s.useCallback((u) => {
    t((p) => ({ ...p, audioDeviceId: u }));
  }, []), a = s.useCallback((u) => {
    t((p) => ({ ...p, videoDeviceId: u }));
  }, []), c = s.useCallback((u) => {
    t((p) => ({ ...p, username: u }));
  }, []);
  return s.useEffect(() => {
    kt(n, e.preventSave ?? !1);
  }, [n, e.preventSave]), {
    userChoices: n,
    saveAudioInputEnabled: r,
    saveVideoInputEnabled: o,
    saveAudioInputDeviceId: i,
    saveVideoInputDeviceId: a,
    saveUsername: c
  };
}
function ar(e, n = {}) {
  const t = Y(e), r = U(n.room), o = s.useMemo(() => wt(r, t), [r, t]);
  return O(
    o,
    t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)
  );
}
function ir(e, n = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const t = Pt(e) ? e.publication.track : e, [r, o] = s.useState(0);
  return s.useEffect(() => {
    if (!t || !t.mediaStream)
      return;
    const { cleanup: i, analyser: a } = be(t, n), c = a.frequencyBinCount, u = new Uint8Array(c), h = setInterval(() => {
      a.getByteFrequencyData(u);
      let l = 0;
      for (let d = 0; d < u.length; d++) {
        const v = u[d];
        l += v * v;
      }
      o(Math.sqrt(l / u.length) / 255);
    }, 1e3 / 30);
    return () => {
      i(), clearInterval(h);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), r;
}
const sn = (e) => {
  const n = (t) => {
    let i = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;
    return i = Math.sqrt(i), i;
  };
  return e.map((t) => t === -1 / 0 ? 0 : n(t));
}, on = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function cr(e, n = {}) {
  var a;
  const t = e instanceof E ? e : (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track, r = { ...on, ...n }, [o, i] = s.useState(
    new Array(r.bands).fill(0)
  );
  return s.useEffect(() => {
    if (!t || !(t != null && t.mediaStream)) {
      i((v) => v.slice().fill(0));
      return;
    }
    const { analyser: c, cleanup: u } = be(t, r.analyserOptions), p = c.frequencyBinCount, h = new Float32Array(p), d = setInterval(() => {
      c.getFloatFrequencyData(h);
      let v = new Float32Array(h.length);
      for (let P = 0; P < h.length; P++)
        v[P] = h[P];
      v = v.slice(r.loPass, r.hiPass);
      const M = sn(v), w = M.length, A = [];
      for (let P = 0; P < r.bands; P++) {
        const D = Math.floor(P * w / r.bands), R = Math.floor((P + 1) * w / r.bands), m = M.slice(D, R), f = m.length;
        if (f === 0)
          A.push(0);
        else {
          const b = m.reduce((g, y) => g += y, 0);
          A.push(b / f);
        }
      }
      i(A);
    }, r.updateInterval);
    return () => {
      u(), clearInterval(d);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), o;
}
const an = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function ur(e, n = {}) {
  var h;
  const t = e instanceof E ? e : (h = e == null ? void 0 : e.publication) == null ? void 0 : h.track, r = { ...an, ...n }, o = s.useRef(new Float32Array()), i = s.useRef(performance.now()), a = s.useRef(0), [c, u] = s.useState([]), p = s.useCallback((l) => {
    u(
      Array.from(
        un(l, r.barCount).map((d) => Math.sqrt(d) * r.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return s.useEffect(() => {
    if (!t || !(t != null && t.mediaStream))
      return;
    const { analyser: l, cleanup: d } = be(t, {
      fftSize: ke(r.barCount)
    }), v = ke(r.barCount), M = new Float32Array(v), w = () => {
      if (A = requestAnimationFrame(w), l.getFloatTimeDomainData(M), o.current.map((P, D) => P + M[D]), a.current += 1, performance.now() - i.current >= r.updateInterval) {
        const P = M.map((D) => D / a.current);
        p(P), i.current = performance.now(), a.current = 0;
      }
    };
    let A = requestAnimationFrame(w);
    return () => {
      d(), cancelAnimationFrame(A);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), p]), {
    bars: c
  };
}
function ke(e) {
  return e < 32 ? 32 : cn(e);
}
function cn(e) {
  let n = 2;
  for (; e >>= 1; )
    n <<= 1;
  return n;
}
function un(e, n) {
  const t = Math.floor(e.length / n), r = new Float32Array(n);
  for (let o = 0; o < n; o++) {
    const i = t * o;
    let a = 0;
    for (let c = 0; c < t; c++)
      a = a + Math.abs(e[i + c]);
    r[o] = a / t;
  }
  return r;
}
function ie(e, n = {}) {
  let t, r;
  typeof n == "string" ? t = n : (t = n == null ? void 0 : n.participantIdentity, r = n == null ? void 0 : n.room);
  const o = he(), i = Xt({ room: r, updateOnlyOn: [] }), a = s.useMemo(() => t ? i.find((p) => p.identity === t) : o, [t, i, o]), c = s.useMemo(() => {
    if (a)
      return Lt(a, { sources: e });
  }, [a, JSON.stringify(e)]);
  return O(c, []);
}
function dn(e) {
  var t, r, o;
  const n = s.useMemo(
    () => {
      var i;
      return (i = e == null ? void 0 : e.publication) != null && i.track ? At(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]
  );
  return O(n, {
    timestamp: Date.now(),
    rtpTimestamp: (o = (r = e == null ? void 0 : e.publication) == null ? void 0 : r.track) == null ? void 0 : o.rtpTimestamp
  });
}
const ln = {
  bufferSize: 100
  // maxAge: 2_000,
};
function fn(e, n) {
  const t = { ...ln, ...n }, [r, o] = s.useState([]), i = dn(e), a = (c) => {
    var u;
    (u = t.onTranscription) == null || u.call(t, c), o(
      (p) => Ot(
        p,
        // when first receiving a segment, add the current media timestamp to it
        c.map((h) => Dt(h, i)),
        t.bufferSize
      )
    );
  };
  return s.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const c = Rt(e.publication).subscribe((u) => {
      a(...u);
    });
    return () => {
      c.unsubscribe();
    };
  }, [e && me(e), a]), { segments: r };
}
function mn(e = {}) {
  const n = he(), t = e.participant ?? n, r = s.useMemo(
    // weird typescript constraint
    () => t ? le(t) : le(t),
    [t]
  );
  return O(r, {
    attributes: t == null ? void 0 : t.attributes
  });
}
function dr(e, n = {}) {
  const t = Y(n.participant), [r, o] = s.useState(t.attributes[e]);
  return s.useEffect(() => {
    if (!t)
      return;
    const i = le(t).subscribe((a) => {
      a.changed[e] !== void 0 && o(a.attributes[e]);
    });
    return () => {
      i.unsubscribe();
    };
  }, [t, e]), r;
}
const we = $.AgentState;
function lr() {
  const e = ve(), n = e.find(
    (l) => l.kind === ae.AGENT && !($.PublishOnBehalf in l.attributes)
  ), t = e.find(
    (l) => l.kind === ae.AGENT && l.attributes[$.PublishOnBehalf] === (n == null ? void 0 : n.identity)
  ), r = ie(
    [E.Source.Microphone, E.Source.Camera],
    n == null ? void 0 : n.identity
  ), o = ie(
    [E.Source.Microphone, E.Source.Camera],
    t == null ? void 0 : t.identity
  ), i = r.find((l) => l.source === E.Source.Microphone) ?? o.find((l) => l.source === E.Source.Microphone), a = r.find((l) => l.source === E.Source.Camera) ?? o.find((l) => l.source === E.Source.Camera), { segments: c } = fn(i), u = re(), { attributes: p } = mn({ participant: n }), h = s.useMemo(() => u === I.Disconnected ? "disconnected" : u === I.Connecting || !n || !(p != null && p[we]) ? "connecting" : p[we], [p, n, u]);
  return {
    agent: n,
    state: h,
    audioTrack: i,
    videoTrack: a,
    agentTranscriptions: c,
    agentAttributes: p
  };
}
function fr(e) {
  const n = U(e), t = re(n), r = s.useMemo(() => It(n), [n, t]);
  return O(r, n.isRecording);
}
function pn(e, n) {
  const t = U(n == null ? void 0 : n.room), o = re(t) === I.Disconnected, i = s.useMemo(() => Nt(t, e), [t, e]);
  return { textStreams: O(o ? void 0 : i, []) };
}
function hn(e) {
  const { participantIdentities: n, trackSids: t } = e ?? {}, { textStreams: r } = pn(_t.TRANSCRIPTION, { room: e == null ? void 0 : e.room });
  return s.useMemo(
    () => r.filter(
      (i) => n ? n.includes(i.participantInfo.identity) : !0
    ).filter(
      (i) => {
        var a;
        return t ? t.includes(
          ((a = i.streamInfo.attributes) == null ? void 0 : a[$.TranscribedTrackId]) ?? ""
        ) : !0;
      }
    ),
    [r, n, t]
  );
}
const Pe = 2, Le = 400, Ae = 3, Re = 1e3;
function mr(e) {
  const n = ue([]), t = Be(() => new Bt(), []), r = ne(async () => t.lock().then(async (h) => {
    for (; ; ) {
      const l = n.current.pop();
      if (!l) {
        h();
        break;
      }
      switch (l.type) {
        case "connect":
          await l.room.connect(...l.args).then(l.resolve).catch(l.reject);
          break;
        case "disconnect":
          await l.room.disconnect(...l.args).then(l.resolve).catch(l.reject);
          break;
      }
    }
  }), []), o = ue([]), i = ne((h) => {
    let l = 0;
    o.current = o.current.filter((d) => {
      const v = h.getTime() - d.getTime() < Re;
      return v && (l += 1), v;
    }), l > Ae && j.warn(
      `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${Ae}x in ${Re}ms). This is not recommended.`
    );
  }, []);
  Ve(() => {
    n.current = [];
    const h = /* @__PURE__ */ new Date();
    o.current.push(h), i(h);
  }, [e, i]);
  const a = ue([]), c = ne((h) => {
    let l = 0;
    a.current = a.current.filter((d) => {
      const v = h.getTime() - d.getTime() < Le;
      return v && (l += 1), v;
    }), l > Pe && j.warn(
      `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${Pe}x in ${Le}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`
    );
  }, []), u = ne(
    async (...h) => new Promise((l, d) => {
      if (!e)
        throw new Error("Called connect(), but room was unset");
      const v = /* @__PURE__ */ new Date();
      c(v), n.current.push({ type: "connect", room: e, args: h, resolve: l, reject: d }), a.current.push(v), r();
    }),
    [e, c, r]
  ), p = ne(
    async (...h) => new Promise((l, d) => {
      if (!e)
        throw new Error("Called discconnect(), but room was unset");
      const v = /* @__PURE__ */ new Date();
      c(v), n.current.push({ type: "disconnect", room: e, args: h, resolve: l, reject: d }), a.current.push(v), r();
    }),
    [e, c, r]
  );
  return {
    connect: e ? u : null,
    disconnect: e ? p : null
  };
}
var oe = { exports: {} }, Oe;
function bn() {
  if (Oe) return oe.exports;
  Oe = 1;
  var e = typeof Reflect == "object" ? Reflect : null, n = e && typeof e.apply == "function" ? e.apply : function(f, b, g) {
    return Function.prototype.apply.call(f, b, g);
  }, t;
  e && typeof e.ownKeys == "function" ? t = e.ownKeys : Object.getOwnPropertySymbols ? t = function(f) {
    return Object.getOwnPropertyNames(f).concat(Object.getOwnPropertySymbols(f));
  } : t = function(f) {
    return Object.getOwnPropertyNames(f);
  };
  function r(m) {
    console && console.warn && console.warn(m);
  }
  var o = Number.isNaN || function(f) {
    return f !== f;
  };
  function i() {
    i.init.call(this);
  }
  oe.exports = i, oe.exports.once = P, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var a = 10;
  function c(m) {
    if (typeof m != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof m);
  }
  Object.defineProperty(i, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(m) {
      if (typeof m != "number" || m < 0 || o(m))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + m + ".");
      a = m;
    }
  }), i.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(f) {
    if (typeof f != "number" || f < 0 || o(f))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + f + ".");
    return this._maxListeners = f, this;
  };
  function u(m) {
    return m._maxListeners === void 0 ? i.defaultMaxListeners : m._maxListeners;
  }
  i.prototype.getMaxListeners = function() {
    return u(this);
  }, i.prototype.emit = function(f) {
    for (var b = [], g = 1; g < arguments.length; g++) b.push(arguments[g]);
    var y = f === "error", T = this._events;
    if (T !== void 0)
      y = y && T.error === void 0;
    else if (!y)
      return !1;
    if (y) {
      var C;
      if (b.length > 0 && (C = b[0]), C instanceof Error)
        throw C;
      var k = new Error("Unhandled error." + (C ? " (" + C.message + ")" : ""));
      throw k.context = C, k;
    }
    var F = T[f];
    if (F === void 0)
      return !1;
    if (typeof F == "function")
      n(F, this, b);
    else
      for (var B = F.length, H = M(F, B), g = 0; g < B; ++g)
        n(H[g], this, b);
    return !0;
  };
  function p(m, f, b, g) {
    var y, T, C;
    if (c(b), T = m._events, T === void 0 ? (T = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (T.newListener !== void 0 && (m.emit(
      "newListener",
      f,
      b.listener ? b.listener : b
    ), T = m._events), C = T[f]), C === void 0)
      C = T[f] = b, ++m._eventsCount;
    else if (typeof C == "function" ? C = T[f] = g ? [b, C] : [C, b] : g ? C.unshift(b) : C.push(b), y = u(m), y > 0 && C.length > y && !C.warned) {
      C.warned = !0;
      var k = new Error("Possible EventEmitter memory leak detected. " + C.length + " " + String(f) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      k.name = "MaxListenersExceededWarning", k.emitter = m, k.type = f, k.count = C.length, r(k);
    }
    return m;
  }
  i.prototype.addListener = function(f, b) {
    return p(this, f, b, !1);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(f, b) {
    return p(this, f, b, !0);
  };
  function h() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(m, f, b) {
    var g = { fired: !1, wrapFn: void 0, target: m, type: f, listener: b }, y = h.bind(g);
    return y.listener = b, g.wrapFn = y, y;
  }
  i.prototype.once = function(f, b) {
    return c(b), this.on(f, l(this, f, b)), this;
  }, i.prototype.prependOnceListener = function(f, b) {
    return c(b), this.prependListener(f, l(this, f, b)), this;
  }, i.prototype.removeListener = function(f, b) {
    var g, y, T, C, k;
    if (c(b), y = this._events, y === void 0)
      return this;
    if (g = y[f], g === void 0)
      return this;
    if (g === b || g.listener === b)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete y[f], y.removeListener && this.emit("removeListener", f, g.listener || b));
    else if (typeof g != "function") {
      for (T = -1, C = g.length - 1; C >= 0; C--)
        if (g[C] === b || g[C].listener === b) {
          k = g[C].listener, T = C;
          break;
        }
      if (T < 0)
        return this;
      T === 0 ? g.shift() : w(g, T), g.length === 1 && (y[f] = g[0]), y.removeListener !== void 0 && this.emit("removeListener", f, k || b);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(f) {
    var b, g, y;
    if (g = this._events, g === void 0)
      return this;
    if (g.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : g[f] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete g[f]), this;
    if (arguments.length === 0) {
      var T = Object.keys(g), C;
      for (y = 0; y < T.length; ++y)
        C = T[y], C !== "removeListener" && this.removeAllListeners(C);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (b = g[f], typeof b == "function")
      this.removeListener(f, b);
    else if (b !== void 0)
      for (y = b.length - 1; y >= 0; y--)
        this.removeListener(f, b[y]);
    return this;
  };
  function d(m, f, b) {
    var g = m._events;
    if (g === void 0)
      return [];
    var y = g[f];
    return y === void 0 ? [] : typeof y == "function" ? b ? [y.listener || y] : [y] : b ? A(y) : M(y, y.length);
  }
  i.prototype.listeners = function(f) {
    return d(this, f, !0);
  }, i.prototype.rawListeners = function(f) {
    return d(this, f, !1);
  }, i.listenerCount = function(m, f) {
    return typeof m.listenerCount == "function" ? m.listenerCount(f) : v.call(m, f);
  }, i.prototype.listenerCount = v;
  function v(m) {
    var f = this._events;
    if (f !== void 0) {
      var b = f[m];
      if (typeof b == "function")
        return 1;
      if (b !== void 0)
        return b.length;
    }
    return 0;
  }
  i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function M(m, f) {
    for (var b = new Array(f), g = 0; g < f; ++g)
      b[g] = m[g];
    return b;
  }
  function w(m, f) {
    for (; f + 1 < m.length; f++)
      m[f] = m[f + 1];
    m.pop();
  }
  function A(m) {
    for (var f = new Array(m.length), b = 0; b < f.length; ++b)
      f[b] = m[b].listener || m[b];
    return f;
  }
  function P(m, f) {
    return new Promise(function(b, g) {
      function y(C) {
        m.removeListener(f, T), g(C);
      }
      function T() {
        typeof m.removeListener == "function" && m.removeListener("error", y), b([].slice.call(arguments));
      }
      R(m, f, T, { once: !0 }), f !== "error" && D(m, y, { once: !0 });
    });
  }
  function D(m, f, b) {
    typeof m.on == "function" && R(m, "error", f, b);
  }
  function R(m, f, b, g) {
    if (typeof m.on == "function")
      g.once ? m.once(f, b) : m.on(f, b);
    else if (typeof m.addEventListener == "function")
      m.addEventListener(f, function y(T) {
        g.once && m.removeEventListener(f, y), b(T);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof m);
  }
  return oe.exports;
}
var ge = bn();
const vn = 2e4;
var gn = /* @__PURE__ */ ((e) => (e.CameraChanged = "cameraChanged", e.MicrophoneChanged = "microphoneChanged", e.StateChanged = "stateChanged", e))(gn || {});
const x = (e) => ({
  isConnected: e === "listening" || e === "thinking" || e === "speaking",
  canListen: e === "pre-connect-buffering" || e === "listening" || e === "thinking" || e === "speaking",
  isFinished: e === "disconnected" || e === "failed",
  isPending: e === "connecting" || e === "initializing" || e === "idle"
}), Sn = () => {
  const [e, n] = s.useState(
    null
  ), [t, r] = s.useState(
    null
  ), o = s.useRef("connecting"), i = s.useRef(!1), a = (c) => setTimeout(() => {
    if (!i.current) {
      n("Agent did not join the room.");
      return;
    }
    const { isConnected: u } = x(o.current);
    if (!u) {
      n("Agent joined the room but did not complete initializing.");
      return;
    }
  }, c ?? vn);
  return {
    agentTimeoutFailureReason: e,
    startAgentTimeout: s.useCallback(
      (c) => {
        t && clearTimeout(t), n(null), r(a(c)), o.current = "connecting", i.current = !1;
      },
      [t]
    ),
    clearAgentTimeout: s.useCallback(() => {
      t && clearTimeout(t), n(null), r(null), o.current = "connecting", i.current = !1;
    }, [t]),
    clearAgentTimeoutFailureReason: s.useCallback(() => {
      n(null);
    }, []),
    updateAgentTimeoutState: s.useCallback((c) => {
      o.current = c;
    }, []),
    updateAgentTimeoutParticipantExists: s.useCallback((c) => {
      i.current = c;
    }, [])
  };
};
function yn(e, n) {
  const t = s.useRef(n);
  s.useEffect(() => {
    t.current = n;
  }, [n]);
  const r = s.useCallback(
    async (a) => {
      const { isConnected: c } = x(t.current);
      if (!c)
        return new Promise((u, p) => {
          const h = (v) => {
            const { isConnected: M } = x(v);
            M && (d(), u());
          }, l = () => {
            d(), p(new Error("useAgent(/* ... */).waitUntilConnected - signal aborted"));
          }, d = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", l);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", l);
        });
    },
    [e]
  ), o = s.useCallback(
    async (a) => {
      const { canListen: c } = x(t.current);
      if (!c)
        return new Promise((u, p) => {
          const h = (v) => {
            const { canListen: M } = x(v);
            M && (d(), u());
          }, l = () => {
            d(), p(new Error("useAgent(/* ... */).waitUntilCouldBeListening - signal aborted"));
          }, d = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", l);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", l);
        });
    },
    [e]
  ), i = s.useCallback(
    async (a) => {
      const { isFinished: c } = x(t.current);
      if (!c)
        return new Promise((u, p) => {
          const h = (v) => {
            const { isFinished: M } = x(v);
            M && (d(), u());
          }, l = () => {
            d(), p(new Error("useAgent(/* ... */).waitUntilFinished - signal aborted"));
          }, d = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", l);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", l);
        });
    },
    [e]
  );
  return { waitUntilConnected: r, waitUntilCouldBeListening: o, waitUntilFinished: i };
}
function Ue(e) {
  const n = Ft();
  if (e = e ?? n, !e)
    throw new Error(
      "No session provided, make sure you are inside a Session context or pass the session explicitly"
    );
  const {
    room: t,
    internal: {
      agentConnectTimeoutMilliseconds: r,
      agentTimeoutFailureReason: o,
      startAgentTimeout: i,
      clearAgentTimeout: a,
      clearAgentTimeoutFailureReason: c,
      updateAgentTimeoutState: u,
      updateAgentTimeoutParticipantExists: p
    }
  } = e, h = s.useMemo(() => new ge.EventEmitter(), []), l = ve({ room: t }), d = s.useMemo(() => l.find(
    (S) => S.kind === ae.AGENT && !($.PublishOnBehalf in S.attributes)
  ) ?? null, [l]), v = s.useMemo(() => d ? l.find(
    (S) => S.kind === ae.AGENT && S.attributes[$.PublishOnBehalf] === d.identity
  ) ?? null : null, [d, l]), [M, w] = s.useState((d == null ? void 0 : d.attributes) ?? {});
  s.useEffect(() => {
    if (!d)
      return;
    const S = (_) => {
      w(_);
    };
    return d.on(ee.AttributesChanged, S), () => {
      d.off(ee.AttributesChanged, S);
    };
  }, [d, h]);
  const A = ie([E.Source.Camera, E.Source.Microphone], {
    room: t,
    participantIdentity: d == null ? void 0 : d.identity
  }), P = ie([E.Source.Camera, E.Source.Microphone], {
    room: t,
    participantIdentity: v == null ? void 0 : v.identity
  }), D = s.useMemo(
    () => A.find((S) => S.source === E.Source.Camera) ?? P.find((S) => S.source === E.Source.Camera),
    [A, P]
  );
  s.useEffect(() => {
    h.emit("cameraChanged", D);
  }, [h, D]);
  const R = s.useMemo(
    () => A.find((S) => S.source === E.Source.Microphone) ?? P.find((S) => S.source === E.Source.Microphone),
    [A, P]
  );
  s.useEffect(() => {
    h.emit("microphoneChanged", R);
  }, [h, R]);
  const [m, f] = s.useState(t.state);
  s.useEffect(() => {
    const S = (_) => {
      f(_);
    };
    return t.on(V.ConnectionStateChanged, S), () => {
      t.off(V.ConnectionStateChanged, S);
    };
  }, [t]), s.useEffect(() => {
    d && c();
  }, [d]);
  const [b, g] = s.useState(null);
  s.useEffect(() => {
    if (!d)
      return;
    const S = (_) => {
      _.identity === (d == null ? void 0 : d.identity) && g("Agent left the room unexpectedly.");
    };
    return t.on(V.ParticipantDisconnected, S), () => {
      t.off(V.ParticipantDisconnected, S);
    };
  }, [d, t]), s.useEffect(() => {
    m === I.Disconnected && g(null);
  }, [m]);
  const [y, T] = s.useState(
    () => t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null
  );
  s.useEffect(() => {
    const S = () => {
      T(t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null);
    }, _ = () => {
      T(null);
    };
    return t.localParticipant.on(
      ee.LocalTrackPublished,
      S
    ), t.localParticipant.on(
      ee.LocalTrackUnpublished,
      _
    ), () => {
      t.localParticipant.off(
        ee.LocalTrackPublished,
        S
      ), t.localParticipant.off(
        ee.LocalTrackUnpublished,
        _
      );
    };
  }, [t.localParticipant]);
  const C = s.useMemo(() => {
    const S = [];
    return o && S.push(o), b && S.push(b), S;
  }, [o, b]), k = s.useMemo(() => {
    if (C.length > 0)
      return "failed";
    let S = "disconnected";
    return m !== I.Disconnected && (S = "connecting"), y && (S = "pre-connect-buffering"), d && M[$.AgentState] && (S = M[$.AgentState]), S;
  }, [
    C,
    m,
    y,
    d,
    M
  ]);
  s.useEffect(() => {
    h.emit("stateChanged", k), u(k);
  }, [h, k]), s.useEffect(() => {
    p(d !== null);
  }, [d]);
  const F = e.connectionState === "disconnected";
  s.useEffect(() => {
    if (!F)
      return i(r), () => {
        a();
      };
  }, [F, r]);
  const {
    identity: B,
    name: H,
    metadata: K
  } = Yt({ participant: d ?? void 0 }), te = s.useMemo(() => {
    const S = {
      attributes: M,
      internal: {
        agentParticipant: d,
        workerParticipant: v,
        emitter: h
      }
    };
    switch (k) {
      case "disconnected":
        return {
          ...S,
          identity: void 0,
          name: void 0,
          metadata: void 0,
          state: k,
          ...x(k),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "connecting":
        return {
          ...S,
          identity: void 0,
          name: void 0,
          metadata: void 0,
          state: k,
          ...x(k),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "initializing":
      case "idle":
        return {
          ...S,
          identity: B,
          name: H,
          metadata: K,
          state: k,
          ...x(k),
          failureReasons: null,
          cameraTrack: D,
          microphoneTrack: R
        };
      case "pre-connect-buffering":
        return {
          ...S,
          identity: B,
          name: H,
          metadata: K,
          state: k,
          ...x(k),
          failureReasons: null,
          cameraTrack: D,
          microphoneTrack: R
        };
      case "listening":
      case "thinking":
      case "speaking":
        return {
          ...S,
          identity: B,
          name: H,
          metadata: K,
          state: k,
          ...x(k),
          failureReasons: null,
          cameraTrack: D,
          microphoneTrack: R
        };
      case "failed":
        return {
          ...S,
          identity: void 0,
          name: void 0,
          metadata: void 0,
          state: "failed",
          ...x("failed"),
          failureReasons: C,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
    }
  }, [
    B,
    H,
    K,
    M,
    h,
    d,
    k,
    D,
    R
  ]), { waitUntilConnected: X, waitUntilCouldBeListening: L, waitUntilFinished: N } = yn(h, k), q = s.useCallback(
    (S) => new Promise((_, Z) => {
      const W = (J) => {
        J && (G(), _(J));
      }, z = () => {
        G(), Z(new Error("useAgent(/* ... */).waitUntilCamera - signal aborted"));
      }, G = () => {
        h.off("cameraChanged", W), S == null || S.removeEventListener("abort", z);
      };
      h.on("cameraChanged", W), S == null || S.addEventListener("abort", z);
    }),
    [h]
  ), se = s.useCallback(
    (S) => new Promise((_, Z) => {
      const W = (J) => {
        J && (G(), _(J));
      }, z = () => {
        G(), Z(new Error("useAgent(/* ... */).waitUntilMicrophone - signal aborted"));
      }, G = () => {
        h.off("microphoneChanged", W), S == null || S.removeEventListener("abort", z);
      };
      h.on("microphoneChanged", W), S == null || S.addEventListener("abort", z);
    }),
    [h]
  );
  return s.useMemo(() => ({
    ...te,
    waitUntilConnected: X,
    waitUntilCouldBeListening: L,
    waitUntilFinished: N,
    waitUntilCamera: q,
    waitUntilMicrophone: se
  }), [
    te,
    X,
    L,
    N,
    q,
    se
  ]);
}
var Cn = /* @__PURE__ */ ((e) => (e.ConnectionStateChanged = "connectionStateChanged", e.MediaDevicesError = "mediaDevicesError", e.EncryptionError = "encryptionError", e))(Cn || {});
function Mn(e, n) {
  const t = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(n)]);
  for (const r of t)
    switch (r) {
      case "roomName":
      case "participantName":
      case "participantIdentity":
      case "participantMetadata":
      case "participantAttributes":
      case "agentName":
      case "agentMetadata":
        if (e[r] !== n[r])
          return !1;
        break;
      default:
        const o = r;
        throw new Error(`Options key ${o} not being checked for equality!`);
    }
  return !0;
}
function Tn(e, n) {
  const t = s.useRef(n);
  return s.useEffect(() => {
    t.current = n;
  }, [n]), s.useCallback(
    async (o, i) => {
      if (t.current !== o)
        return new Promise((a, c) => {
          const u = (l) => {
            l === o && (h(), a());
          }, p = () => {
            h(), c(
              new Error(
                `useSession(/* ... */).waitUntilConnectionState(${o}, /* signal */) - signal aborted`
              )
            );
          }, h = () => {
            e.off("connectionStateChanged", u), i == null || i.removeEventListener("abort", p);
          };
          e.on("connectionStateChanged", u), i == null || i.addEventListener("abort", p);
        });
    },
    [e]
  );
}
function En(e, n) {
  const t = e instanceof qt, r = s.useRef(
    t ? n : null
  );
  return s.useEffect(() => {
    if (!t) {
      r.current = null;
      return;
    }
    r.current !== null && Mn(r.current, n) || (r.current = n);
  }, [t, n]), s.useCallback(async () => {
    if (t) {
      if (!r.current)
        throw new Error(
          "AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!"
        );
      return e.fetch(r.current);
    } else
      return e.fetch();
  }, [t, e]);
}
function pr(e, n = {}) {
  const { room: t, agentConnectTimeoutMilliseconds: r, ...o } = n, i = pe(), a = s.useMemo(
    () => i ?? t ?? new Fe(),
    [i, t]
  ), c = s.useMemo(
    () => new ge.EventEmitter(),
    []
  ), u = s.useCallback(
    (L) => ({
      isConnected: L === I.Connected || L === I.Reconnecting || L === I.SignalReconnecting
    }),
    []
  ), [p, h] = s.useState(a.state);
  s.useEffect(() => {
    const L = (N) => {
      h(N);
    };
    return a.on(V.ConnectionStateChanged, L), () => {
      a.off(V.ConnectionStateChanged, L);
    };
  }, [a]), s.useEffect(() => {
    const L = async (N) => {
      c.emit("mediaDevicesError", N);
    };
    return a.on(V.MediaDevicesError, L), () => {
      a.off(V.MediaDevicesError, L);
    };
  }, [a, c]), s.useEffect(() => {
    const L = async (N) => {
      c.emit("encryptionError", N);
    };
    return a.on(V.EncryptionError, L), () => {
      a.off(V.EncryptionError, L);
    };
  }, [a, c]);
  const { localParticipant: l } = xe({ room: a }), d = l.getTrackPublication(E.Source.Camera), v = s.useMemo(() => {
    if (d)
      return {
        source: E.Source.Camera,
        participant: l,
        publication: d
      };
  }, [l, d]), M = l.getTrackPublication(E.Source.Microphone), w = s.useMemo(() => {
    if (M)
      return {
        source: E.Source.Microphone,
        participant: l,
        publication: M
      };
  }, [l, M]), A = l.getTrackPublication(E.Source.ScreenShare), P = s.useMemo(() => {
    if (A)
      return {
        source: E.Source.ScreenShare,
        participant: l,
        publication: A
      };
  }, [l, A]), {
    agentTimeoutFailureReason: D,
    startAgentTimeout: R,
    clearAgentTimeout: m,
    clearAgentTimeoutFailureReason: f,
    updateAgentTimeoutState: b,
    updateAgentTimeoutParticipantExists: g
  } = Sn(), y = s.useMemo(
    () => ({
      emitter: c,
      tokenSource: e,
      agentConnectTimeoutMilliseconds: r,
      agentTimeoutFailureReason: D,
      startAgentTimeout: R,
      clearAgentTimeout: m,
      clearAgentTimeoutFailureReason: f,
      updateAgentTimeoutState: b,
      updateAgentTimeoutParticipantExists: g
    }),
    [
      c,
      r,
      e,
      D,
      R,
      m,
      f,
      b,
      g
    ]
  ), T = s.useMemo(() => {
    const L = {
      room: a,
      internal: y
    };
    switch (p) {
      case I.Connecting:
        return {
          ...L,
          connectionState: I.Connecting,
          ...u(I.Connecting),
          local: {
            cameraTrack: void 0,
            microphoneTrack: void 0,
            screenShareTrack: void 0
          }
        };
      case I.Connected:
      case I.Reconnecting:
      case I.SignalReconnecting:
        return {
          ...L,
          connectionState: p,
          ...u(p),
          local: {
            cameraTrack: v,
            microphoneTrack: w,
            screenShareTrack: P
          }
        };
      case I.Disconnected:
        return {
          ...L,
          connectionState: I.Disconnected,
          ...u(I.Disconnected),
          local: {
            cameraTrack: void 0,
            microphoneTrack: void 0,
            screenShareTrack: void 0
          }
        };
    }
  }, [
    y,
    a,
    p,
    v,
    w,
    u
  ]);
  s.useEffect(() => {
    c.emit("connectionStateChanged", T.connectionState);
  }, [c, T.connectionState]);
  const C = Tn(
    c,
    T.connectionState
  ), k = s.useCallback(
    async (L) => C(
      I.Connected,
      L
    ),
    [C]
  ), F = s.useCallback(
    async (L) => C(I.Disconnected, L),
    [C]
  ), B = Ue(
    s.useMemo(
      () => ({
        connectionState: T.connectionState,
        room: a,
        internal: y
      }),
      [T, a, y]
    )
  ), H = En(e, o), K = s.useCallback(
    async (L = {}) => {
      var Z, W, z, G, J, Se;
      const {
        signal: N,
        tracks: q = { microphone: { enabled: !0, publishOptions: { preConnectBuffer: !0 } } },
        roomConnectOptions: se
      } = L;
      await F(N);
      const S = () => {
        a.disconnect();
      };
      N == null || N.addEventListener("abort", S);
      let _ = !1;
      await Promise.all([
        H().then(({ serverUrl: He, participantToken: ye }) => {
          var Ce, Me;
          return _ = (((Me = (Ce = Vt(ye).roomConfig) == null ? void 0 : Ce.agents) == null ? void 0 : Me.length) ?? 0) > 0, a.connect(He, ye, se);
        }),
        // Start microphone (with preconnect buffer) by default
        (Z = q.microphone) != null && Z.enabled ? a.localParticipant.setMicrophoneEnabled(
          !0,
          void 0,
          ((W = q.microphone) == null ? void 0 : W.publishOptions) ?? {}
        ) : Promise.resolve(),
        (z = q.camera) != null && z.enabled ? a.localParticipant.setCameraEnabled(
          !0,
          void 0,
          ((G = q.camera) == null ? void 0 : G.publishOptions) ?? {}
        ) : Promise.resolve(),
        (J = q.screenShare) != null && J.enabled ? a.localParticipant.setScreenShareEnabled(
          !0,
          void 0,
          ((Se = q.screenShare) == null ? void 0 : Se.publishOptions) ?? {}
        ) : Promise.resolve()
      ]), await k(N), _ && await B.waitUntilConnected(N), N == null || N.removeEventListener("abort", S);
    },
    [a, F, H, k, B.waitUntilConnected]
  ), te = s.useCallback(async () => {
    await a.disconnect();
  }, [a]), X = s.useCallback(async () => {
    const L = await H();
    await a.prepareConnection(L.serverUrl, L.participantToken);
  }, [H, a]);
  return s.useEffect(
    () => {
      X().catch((L) => {
        console.warn("WARNING: Room.prepareConnection failed:", L);
      });
    },
    [
      /* note: no prepareConnection here, this effect should only ever run once! */
    ]
  ), s.useMemo(
    () => ({
      ...T,
      waitUntilConnected: k,
      waitUntilDisconnected: F,
      prepareConnection: X,
      start: K,
      end: te
    }),
    [T, k, F, X, K, te]
  );
}
function hr(e, n, t, r) {
  const o = s.useMemo(() => () => {
  }, []), i = s.useCallback(t ?? o, r ?? []), a = r ? i : t, c = s.useMemo(() => e ? "internal" in e ? e.internal.emitter : e : null, [e]);
  s.useEffect(() => {
    if (!(!c || !a))
      return c.on(n, a), () => {
        c.off(n, a);
      };
  }, [c, n, a]);
}
var kn = /* @__PURE__ */ ((e) => (e.MessageReceived = "messageReceived", e))(kn || {});
function br(e) {
  const { room: n } = xt(e), t = s.useMemo(
    () => new ge.EventEmitter(),
    []
  ), r = Ue(e), o = hn({ room: n }), i = s.useMemo(() => ({ room: n }), [n]), a = rn(i), c = s.useMemo(() => o.map((d) => {
    var v, M, w;
    switch (d.participantInfo.identity) {
      case n.localParticipant.identity:
        return {
          type: "userTranscript",
          message: d.text,
          id: d.streamInfo.id,
          timestamp: d.streamInfo.timestamp,
          from: n.localParticipant
        };
      case ((v = r.internal.agentParticipant) == null ? void 0 : v.identity):
      case ((M = r.internal.workerParticipant) == null ? void 0 : M.identity):
        return {
          type: "agentTranscript",
          message: d.text,
          id: d.streamInfo.id,
          timestamp: d.streamInfo.timestamp,
          from: ((w = r.internal.agentParticipant) == null ? void 0 : w.identity) === d.participantInfo.identity ? r.internal.agentParticipant : r.internal.workerParticipant
        };
      default:
        return {
          type: "agentTranscript",
          message: d.text,
          id: d.streamInfo.id,
          timestamp: d.streamInfo.timestamp,
          from: Array.from(n.remoteParticipants.values()).find(
            (A) => A.identity === d.participantInfo.identity
          )
        };
    }
  }), [o, n]), u = s.useMemo(() => [...c, ...a.chatMessages], [c, a.chatMessages]), p = s.useRef(/* @__PURE__ */ new Map()), h = s.useMemo(() => {
    const d = /* @__PURE__ */ new Date();
    for (const v of u)
      p.current.has(v.id) || p.current.set(v.id, d);
    return u.sort((v, M) => {
      const w = p.current.get(v.id), A = p.current.get(M.id);
      return typeof w > "u" || typeof A > "u" ? 0 : w.getTime() - A.getTime();
    });
  }, [u]), l = s.useRef(/* @__PURE__ */ new Set());
  return s.useEffect(() => {
    for (const d of h)
      l.current.has(d.id) || (l.current.add(d.id), t.emit("messageReceived", d));
  }, [h]), s.useMemo(
    () => ({
      messages: h,
      send: a.send,
      isSending: a.isSending,
      internal: { emitter: t }
    }),
    [h, a.send, a.isSending]
  );
}
export {
  pn as $,
  Bn as A,
  Gn as B,
  xe as C,
  In as D,
  Fn as E,
  $t as F,
  Ee as G,
  Qt as H,
  Yt as I,
  Wn as J,
  Xt as K,
  Jn as L,
  ve as M,
  Qn as N,
  Zt as O,
  er as P,
  sr as Q,
  gn as R,
  Ue as S,
  ir as T,
  ur as U,
  ie as V,
  fn as W,
  lr as X,
  mn as Y,
  dr as Z,
  fr as _,
  re as a,
  hn as a0,
  mr as a1,
  Cn as a2,
  pr as a3,
  hr as a4,
  kn as a5,
  br as a6,
  Zn as b,
  xn as c,
  Un as d,
  Vn as e,
  Kn as f,
  Yn as g,
  nr as h,
  _n as i,
  O as j,
  tr as k,
  zn as l,
  ar as m,
  Hn as n,
  jn as o,
  Xn as p,
  Jt as q,
  Kt as r,
  cr as s,
  rr as t,
  Nn as u,
  $n as v,
  rn as w,
  or as x,
  qn as y,
  Dn as z
};
//# sourceMappingURL=hooks-0IvkS6LV.mjs.map
